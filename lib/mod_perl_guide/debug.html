<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
  <head>
   <title>mod_perl guide: Debugging mod_perl </title>
   <meta name="Author" content="Stas Bekman">
   <meta name="Description" content="All Apache/Perl related information: Hints, Guidelines, Scenarios and Troubleshottings">
   <meta name="keywords" content="mod_perl modperl perl cgi apache webserver speed fast guide mod_perl apache guide help info faq mod_perl installation cgi troubleshooting help no sex speedup free open source OSS mod_perl apache guide">
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Classification" content="information">
   <link href="./style.css" rel=stylesheet type="text/css" title="refstyle">
  </head>
  <body>

    <h1 align=center>
      <a href="http://perl.apache.org"><img src="images/mod_perl.gif" alt="Mod Perl Icon" border=0 height=30 width=90 align=left></a>
      <a href="http://perl.apache.org"><img src="images/mod_perl.gif" alt="Mod Perl Icon" border=0 height=30 width=90 align=right></a>
      Debugging mod_perl 
    </h1>
    <hr>
    <p>
    <div class="navbar">
      <a href="./multiuser.html">Prev</a>                                 |
      <a href="./index.html"         >Contents</a> |
      <a href="./index.html#search"  >Search</a>   |
      <a href="./index.html#download">Download</a> |
      <a href="./browserbugs.html">Next</a>
    </div>
    <p>

    <div class="toc">
      
<A NAME="toc"></A>
<P><B>Table of Contents:</B></P>

<UL>

	<LI><A HREF="#Warning_and_Errors_Explained">Warning and Errors Explained</A>
	<UL>

		<LI><A HREF="#Curing_The_Internal_Server_Erro">Curing The &quot;Internal Server Error&quot;</A>
		<LI><A HREF="#Helping_error_log_to_Help_Us">Helping error_log to Help Us</A>
		<LI><A HREF="#The_Importance_of_Warnings">The Importance of Warnings</A>
		<UL>

			<LI><A HREF="#diagnostics_pragma">diagnostics pragma</A>
		</UL>

	</UL>

	<LI><A HREF="#Handling_the_User_pressed_Stop_">Handling the 'User pressed Stop button' case</A>
	<UL>

		<LI><A HREF="#Detecting_Aborted_Connections">Detecting Aborted Connections</A>
		<LI><A HREF="#The_Importance_of_Cleanup_Code">The Importance of Cleanup Code</A>
		<UL>

			<LI><A HREF="#Critical_Section">Critical Section</A>
			<LI><A HREF="#Safe_Resource_Locking_and_Cleanu">Safe Resource Locking and Cleanup Code</A>
		</UL>

	</UL>

	<LI><A HREF="#Handling_Server_Timeout_Cases_an">Handling Server Timeout Cases and Working with $SIG{ALRM}</A>
	<LI><A HREF="#Looking_inside_the_server">Looking inside the server</A>
	<UL>

		<LI><A HREF="#Apache_Status_Embedded_Inter">Apache::Status - Embedded Interpreter Status Information</A>
		<UL>

			<LI><A HREF="#Minimal_Configuration">Minimal Configuration</A>
			<LI><A HREF="#Extended_Configuration">Extended Configuration</A>
			<LI><A HREF="#Usage">Usage</A>
			<LI><A HREF="#Compiled_Registry_Scripts_sectio">Compiled Registry Scripts section seems to be empty.</A>
		</UL>

		<LI><A HREF="#mod_status">mod_status</A>
		<LI><A HREF="#Apache_VMonitor_Visual_Syste">Apache::VMonitor - Visual System and Apache Server Monitor</A>
	</UL>

	<LI><A HREF="#Sometimes_My_Script_Works_Somet">Sometimes My Script Works, Sometimes It Does Not</A>
	<LI><A HREF="#Code_Debug">Code Debug</A>
	<UL>

		<LI><A HREF="#Locating_and_correcting_Syntax_E">Locating and correcting Syntax Errors</A>
		<LI><A HREF="#Using_Apache_FakeRequest_to_Deb">Using Apache::FakeRequest to Debug Apache Perl Modules</A>
		<LI><A HREF="#Finding_the_Line_Which_Triggered">Finding the Line Which Triggered the Error or Warning</A>
		<LI><A HREF="#Using_print_for_Debugging">Using print() for Debugging</A>
		<LI><A HREF="#Using_print_and_Data_Dumper_f">Using print() and Data::Dumper for Debugging</A>
		<LI><A HREF="#The_Importance_of_a_Good_Concise">The Importance of a Good Concise Coding Style</A>
		<LI><A HREF="#Introduction_to_the_Perl_Debugge">Introduction to the Perl Debugger</A>
		<LI><A HREF="#Interactive_Perl_Debugging_under">Interactive Perl Debugging under mod_cgi</A>
		<LI><A HREF="#Non_Interactive_Perl_Debugging_u">Non-Interactive Perl Debugging under mod_perl</A>
		<LI><A HREF="#Interactive_mod_perl_Debugging">Interactive mod_perl Debugging</A>
		<LI><A HREF="#ptkdb_and_Interactive_mod_perl_D">ptkdb and Interactive mod_perl Debugging</A>
		<LI><A HREF="#Debugging_when_Server_Crashes_on">Debugging when Server Crashes on Startup before Writing to Log File.</A>
	</UL>

	<LI><A HREF="#Hanging_Processes_Detection_and">Hanging Processes: Detection and Diagnostics</A>
	<UL>

		<LI><A HREF="#Hanging_because_of_the_OS_Proble">Hanging because of the OS Problem</A>
		<LI><A HREF="#An_Example_of_Code_that_Might_Ha">An Example of Code that Might Hang a Process</A>
		<LI><A HREF="#Detecting_hanging_processes">Detecting hanging processes</A>
		<LI><A HREF="#Determination_of_the_reason">Determination of the reason</A>
		<UL>

			<LI><A HREF="#Using_the_Perl_Trace">Using the Perl Trace</A>
			<LI><A HREF="#Using_the_System_Calls_Trace">Using the System Calls Trace</A>
			<LI><A HREF="#Using_the_Interactive_Debugger">Using the Interactive Debugger</A>
		</UL>

	</UL>

	<LI><A HREF="#Debugging_Hanging_processes_con">Debugging Hanging processes (continued)</A>
	<UL>

		<LI><A HREF="#Debugging_core_Dumping_Code">Debugging core Dumping Code</A>
	</UL>

	<LI><A HREF="#PERL_DEBUG_1_Build_Option">PERL_DEBUG=1 Build Option</A>
	<LI><A HREF="#Apache_Debug">Apache::Debug</A>
	<LI><A HREF="#Debug_Tracing">Debug Tracing</A>
	<LI><A HREF="#gdb_says_there_are_no_debugging_">gdb says there are no debugging symbols</A>
	<LI><A HREF="#Debugging_Signal_Handlers_SIG_">Debugging Signal Handlers ($SIG{FOO})</A>
	<LI><A HREF="#Code_Profiling">Code Profiling</A>
	<LI><A HREF="#Devel_Peek">Devel::Peek</A>
	<LI><A HREF="#How_can_I_find_out_if_a_mod_perl">How can I find out if a mod_perl code has a memory leak</A>
	<LI><A HREF="#Debugging_your_code_in_Single_Se">Debugging your code in Single Server Mode</A>
	<LI><A HREF="#Apache_DumpHeaders_Watch_HTTP">Apache::DumpHeaders - Watch HTTP Transaction Via Headers</A>
	<LI><A HREF="#Apache_DebugInfo_Log_Various_">Apache::DebugInfo - Log Various Bits Of Per-Request Data</A>
</UL>

    </div>

    [ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
    <table width="60%" align="center">

      <tr>
	<td>
	  <div class="ad">
	    The <a href="http://www.modperl.com/">
	      <B>Writing Apache Modules with Perl and C</B></a>
	    book can be purchased online from <a
	      href="http://www.ora.com/catalog/wrapmod/">O'Reilly </a>
	    and <a
	    href="http://www.amazon.com/exec/obidos/ASIN/156592567X/writinapachemodu">
	      Amazon.com</a>.
	  </div>
	</td>
      </tr>

      <tr>
	<td>
	  <div class="notice">
	  <B>Your corrections of the technical and grammatical
	     errors are very welcome. You are encouraged to help me
	     improve this guide.  If you have something to contribute
	     please <A HREF="help.html#Contacting_me"> send it
	     directly to me</A>.</B>
	  </div>
	</td>
      </tr>

</table>

    

	    [ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>

<P>
<CENTER><H1><A NAME="Warning_and_Errors_Explained">Warning and Errors Explained</A></H1></CENTER>
<P>
Let's talk first about things that bother most web (and non-web)
programmers. <EM>The bothering things</EM> are warning and errors reported by Perl. We are going to learn how to take
the best out of both, by turning this obvious to the newbie programmer
enemies into our best friends.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Curing_The_Internal_Server_Erro">Curing The &quot;Internal Server Error&quot;</A></H2></CENTER>
<P>
You have just installed this new CGI script and when you try it out you see
the grey screen of death saying ``Internal Server Error''... Or even worse
you have a script running on a production server for a long time without
problems, when the same grey screen starts to show up occasionally for no
apparent reason.

<P>
How can we find out what the problem is?

<P>
First problem:

<P>
You have been coding in Perl for years, and whenever an error occurred in
the past it was displayed in the same terminal window that you started the
script from. But when you work with a webserver there is no terminal to
show you the errors, since the server in most cases has no terminal to send
the error messages to.

<P>
Actually, the error messages don't disappear, they end up in the
<EM>error_log</EM> file. It is located in the directory specified by the
<CODE>ErrorLog</CODE> directive in <EM>httpd.conf</EM>. The default setting is generally:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  ErrorLog /usr/local/apache/logs/error_log</pre>
        </td>
	    
      </tr>
    </table>
    <P>
So whenever you see <EM>"Internal Server Error"</EM> it's time to look at this file.

<P>
First problem solved!

<P>
There are cases when errors don't go to the error_log file. For example,
some errors go to the httpd process' STDERR. If you haven't redirected
httpd's STDERR then the messages are printed to the console (tty, terminal)
from which you executed the httpd. This happens when the server didn't get
as far as opening the error_log file for writing before it needed to write
an error message.

<P>
For example, if you have entered a non-existent directory path in your
<CODE>ErrorLog</CODE> directive, the error message will be printed to STDERR. If the error
happens when the server executes a <CODE>PerlRequire</CODE> or
<CODE>PerlModule</CODE> directive you might also see output sent to STDERR.

<P>
You are probably wondering where all the errors go when you are running the
server in single process mode (<CODE>httpd -X</CODE>). They go to STDERR. This is because the error logging for all the httpd
children is normally done by the parent httpd. When httpd runs in single
process mode, it has no parent httpd process to perform all the logging.
The output to the terminal includes all the status messages that normally
go to the error_log file.

<P>
Finally with a <CODE>PerlLogHandler</CODE> you can take away from Apache its control of the error logging process for
all HTTP transactions. If you do this, then you are responsible for
generating and storing the error messages. You can do whatever you like
with the information, (including throwing it away -- don't do it!) and,
depending on how you implement you <CODE>LogHandler</CODE>, the <CODE>ErrorLog</CODE> directive may have no effect. But you can also do something at this handler
and then return
<CODE>DECLINED</CODE> status, so the default Apache LogHandler will do the work as usual.

<P>
Second problem:

<P>
The usefulness of the error message depends to some extent on the
programmer's coding style. An uninformative message might not help you to
spot and fix the error.

<P>
For example, let's take a function which opens a file passed to it as a
parameter. It does nothing else with the file. Here's our first version of
the code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  my $r = shift;
  $r-&gt;send_http_header('text/plain');
  
  sub open_file{
    my $filename = shift || '';
    die &quot;No filename passed!&quot; unless $filename;
  
    open FILE, $filename or die;
  }
  
  open_file(&quot;/tmp/test.txt&quot;);</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Let's assume that <CODE>/tmp/test.txt</CODE> doesn't exist so the <CODE>open()</CODE> will fail to open the file. When
we call this script from our browser, the browser returns an <EM>"internal error"</EM> message and we see the following error appended to <EM>error_log</EM>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  Died at /home/httpd/perl/test.pl line 9.</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We can use the hint Perl kindly gave to us to find where in the code the
<CODE>die()</CODE> was called. However, we still don't know what filename
was passed to this subroutine to cause the program termination.

<P>
If we have only one function call as in the example above, the task of
finding the problematic filename will be trivial. Now let's add two more
<CODE>open_file()</CODE> function calls and assume that among the three
files only <EM>/tmp/test2.txt</EM> exists:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  open_file(&quot;/tmp/test.txt&quot;);
  open_file(&quot;/tmp/test2.txt&quot;);
  open_file(&quot;/tmp/test3.txt&quot;);</pre>
        </td>
	    
      </tr>
    </table>
    <P>
When you execute the above call, you will see the same error message twice:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  Died at /home/httpd/perl/test.pl line 9.
  Died at /home/httpd/perl/test.pl line 9.</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Based on this error message, can you tell what files your program failed to
open? Probably not. Let's fix it by passing the name of the file to
<CODE>die():</CODE>

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  sub open_file{
    my $filename = shift || '';
    die &quot;No filename passed!&quot; unless $filename;
    open FILE, $filename or die &quot;failed to open $filename&quot;;
  }
  
  open_file(&quot;/tmp/test.txt&quot;);</pre>
        </td>
	    
      </tr>
    </table>
    <P>
When we execute the above code, we see:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  failed to open /tmp/test.txt at /home/httpd/perl/test.pl line 9.</pre>
        </td>
	    
      </tr>
    </table>
    <P>
which makes a big difference.

<P>
By the way, if you append a newline to the end of the message you pass to
<CODE>die(),</CODE> Perl won't report the line number the error has
happened at, so if you code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  open FILE, $filename or die &quot;failed to open a file\n&quot;;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The error message will be:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  failed to open a file</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Which gives you very little to go on. It's very hard to debug with such
uninformative error messages.

<P>
The <CODE>warn()</CODE> function, a kinder sister of <CODE>die(),</CODE>
which logs the message but doesn't cause program termination, behaves in
the same way. If you add a newline to the end of the message, the line
number <CODE>warn()</CODE> was called at won't be logged, otherwise it
will.

<P>
You might want to use <CODE>warn()</CODE> instead of <CODE>die()</CODE> if
the failure isn't critical. Consider the following code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  if(open FILE, $filename){
    # do something with file
  } else {
    warn &quot;failed to open $filename&quot;;
  } 
  # more code here...</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now we've improved our code, by reporting the names of the problematic
files, but we still don't know the reason for the failure. Let's try to
improve the <CODE>warn()</CODE> example. The <CODE>-r</CODE> operator tests whether the file is readable:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  if(-r $filename){
    open FILE, $filename;
    # do something with file
  } else {
    warn &quot;Couldn't open $filename - doesn't exist or is not readable&quot;;
  } </pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now if we cannot read the file we do not even try to open it. But we still
see a warning in error_log:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  Couldn't open /tmp/test.txt - doesn't exist or is not readable
  at /home/httpd/perl/test.pl line 9.</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The warning tells us the reason for the failure, so we don't have to go to
the code and check what it was trying to do with the file.

<P>
It could be quite a coding overhead to explain all the possible failure
reasons that way, but why reinvent the wheel? We already have the reason
for the failure stored in the <CODE>$!</CODE> variable. Let's go back to the <CODE>open_file()</CODE> function:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  sub open_file{
    my $filename = shift || '';
    die &quot;No filename passed!&quot; unless $filename;
    open FILE, $filename or die &quot;failed to open $filename: $!&quot;;
  }
  
  open_file(&quot;/tmp/test.txt&quot;);</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This time, if <CODE>open()</CODE> fails we see:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  failed to open /tmp/test.txt: No such file or directory
  at /home/httpd/perl/test.pl line 9.</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now we have all the information we need to debug these problems: we know
what line of code triggered <CODE>die(),</CODE> we know what file we were
trying to open, and last but not least we know the reason, given to us
through Perl's <CODE>$!</CODE> variable.

<P>
Now let's create the file <EM>/tmp/test.txt</EM>.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % touch /tmp/test.txt</pre>
        </td>
	    
      </tr>
    </table>
    <P>
When we execute the latest version of the code, we see:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  failed to open /tmp/test.txt: Permission denied
  at /home/httpd/perl/test.pl line 9.</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Here we see a different reason: we created a file that doesn't belong to
the user which the server runs as (usually <EM>nobody</EM>). It does not have permission to read the file.

<P>
Now you can see that it's much easier to debug your code if you validate
the return values of the system calls, and properly code arguments to
<CODE>die()</CODE> and <CODE>warn()</CODE> calls. The <CODE>open()</CODE>
function is just one of the many system calls perl provides to your
convenience.

<P>
So now you can code and debug CGI scripts and modules as easily as if they
were plain Perl scripts that you execute from a shell.

<P>
Second problem solved!

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Helping_error_log_to_Help_Us">Helping error_log to Help Us</A></H2></CENTER>
<P>
It's a good idea to keep it open all the time in a dedicated terminal with
the help of <EM>tail -f</EM> or <EM>less -S</EM>, whichever you prefer (the latter allows you to page around the file,
search etc.)

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % tail -f /usr/local/apache/logs/error_log</pre>
        </td>
	    
      </tr>
    </table>
    <P>
or

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % less -S /usr/local/apache/logs/error_log</pre>
        </td>
	    
      </tr>
    </table>
    <P>
So you will see all the errors and warning as they happen.

<P>
Another tip is to create a shell <EM>alias</EM>, to make it easier to execute the above command. In tcsh you would do
something like this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % alias err &quot;tail -f /usr/local/apache/logs/error_log&quot;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
For bash users the command is:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % alias err='tail -f /var/log/apache/error.log'</pre>
        </td>
	    
      </tr>
    </table>
    <P>
and from now on in the shell you set the alias in, executing

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % err</pre>
        </td>
	    
      </tr>
    </table>
    <P>
will call <EM>tail -f /usr/local/apache/logs/error_log</EM>. Since you want this alias to be available to you all the time, you should
put it into your <EM>.tcshrc</EM> file or its equivalent. For <EM>bash</EM> users this is
<EM>.bashrc</EM>, or you can put it in <EM>/etc/profile</EM> for use by all users.

<P>
If you cannot access your <EM>error_log</EM> file because you are unable to telnet to your machine (generally the case
with some ISPs who provide user CGI support but no telnet access), you
might want to use a CGI script I wrote to fetch the latest lines from the
file (with a bonus of colored output for easier reading). You might need to
ask your ISP to install this script for general use. See <A HREF="././snippets.html#Watching_the_error_log_File_With">Watching the error_log file without telneting to the server</A> .

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="The_Importance_of_Warnings">The Importance of Warnings</A></H2></CENTER>
<P>
Just like errors, Perl's mandatory warnings go to the <EM>error_log</EM>
file, if the they are enabled. Of course you have enabled them in your
development server, haven't you?

<P>
The code you write lives a dual life. In the first life it's being written,
tested, debugged, improved, tested, debugged, rewritten, tested, debugged.
In the second life it's <EM>just</EM> used.

<P>
A significant part of the script's first life is spent on the developer's
machine. The other part is spent on the production server where the
creature is supposed to be perfect.

<P>
So when you develop the code you want all the help in the world to help you
spot possible problems, and that's where enabling warnings is a must.
Whenever you see an error or warning in the <EM>error_log</EM>, you want to get rid of it. That's very important.

<P>
Why?

<UL>
<P><LI>
<P>
If there are warnings, your code is not clean. If they are waved away,
expect them to come back on the production server in the form of errors,
when it's too late.

<P><LI>
<P>
If each invocation of a script generates more than about five lines of
warnings, it will be very hard to catch real problems. You just can't see
them among all the other warnings which you used to think were unimportant.

</UL>
<P>
On the other hand, on a production server, you really <EM>want</EM> to turn warnings off. And there are good reasons for that:

<UL>
<P><LI>
<P>
There is no added value in having the same warning showing up, again and
again, triggered by thousands of script invocations. If your code isn't
very clean and generates even a single warning per script invocation, on
the heavily loaded server you will end up with a huge
<EM>error_log</EM> file in a short time.

<P>
The warning elimination phase is supposed to be a part of the development
process, and should be done before the code goes live.

<P><LI>
<P>
In any Perl script, not just under mod_perl, enabling runtime warnings has
a performance impact.

</UL>
<P>
mod_perl gives you a very simple solution to this warnings saga, don't
enable warnings in the scripts unless you really have to. Let mod_perl
control this mode globally. All you need to do is put the directive

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlWarn On</pre>
        </td>
	    
      </tr>
    </table>
    <P>
in <EM>httpd.conf</EM> on your development machine and the directive

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlWarn Off</pre>
        </td>
	    
      </tr>
    </table>
    <P>
on the live box.

<P>
If there is a piece of code that generates warnings and you want to disable
them only in this code, you can do that too. The Perl special variable <CODE>$^W</CODE> allows you dynamically to turn on and off warnings mode. So just put the
code into a block, and disable the warnings in the scope of this block. The
original value of <CODE>$^W</CODE> will be restored upon exit from the block.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  {
   local $^W=0;
    # some code that generates innocuous warnings
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Unless you have a really good reason, for your own sake the advice is
<EM>avoid this technique</EM>.

<P>
Don't forget the <CODE>local()</CODE> operand! If you do, setting <CODE>$^W</CODE> will affect <STRONG>all</STRONG> the requests handled by the Apache child that changed this variable. And
for <STRONG>all</STRONG> the scripts it executes, not just the one which changed <CODE>$^W</CODE>!

<P>
The <CODE>diagnostics</CODE> pragma can shed more light on errors and warnings, as you will see in a
moment.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="diagnostics_pragma">diagnostics pragma</A></H3></CENTER>
<P>
This module extends the terse diagnostics normally emitted by both the Perl
compiler and the Perl interpreter, augmenting them with the more verbose
and endearing descriptions found in the <CODE>perldiag</CODE> manpage. Like the other pragmata, it affects the compilation phase of your
scripts as well as the execution phase.

<P>
To use in your program as a pragma, merely invoke

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    use diagnostics;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
at or near the start of your program. This also turns on <CODE>-w</CODE> mode.

<P>
This pragma is especially useful when you are new to perl, and want a
better explanation of the errors and warnings. It's also helpful when you
encounter some warning you've never seen before, e.g. when a new warning
has been introduced in an upgraded version of Perl.

<P>
You may not want to leave <CODE>diagnostics</CODE> mode On for your production server. For each warning, <CODE>diagnostics</CODE> mode generates ten times more output than warnings mode. If your code
generates warnings, with the <CODE>diagnostics</CODE> pragma you will use disk space much faster.

<P>
<CODE>diagnostics</CODE> mode adds a large performance overhead in comparison with just having
warnings mode On. You can see the benchmark results in the section '<A HREF="././performance.html#Code_Profiling_Techniques">Code Profiling Techniques</A>'.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Handling_the_User_pressed_Stop_">Handling the 'User pressed Stop button' case</A></H1></CENTER>
<P>
When a user presses a <STRONG>STOP</STRONG> or <STRONG>RELOAD</STRONG> button, the current socket connection goes broken (aborted). It would be
nice if Apache could always immediately detect this event. Unfortunately
there is no way to tell whether the connection is still valid unless an
attempt to read from or write to connection is made.

<P>
If the reading of the request's data is completed and the code does
processing without writing anything back to the client the broken
connection won't be noticed. When an attempt is made to send at least one
character to the client, the broken connection would be noticed and the <CODE>SIGPIPE</CODE> signal (Broken pipe) would be sent to the process. The program could then
halt its execution and perform all the cleanup stuff it has to do.

<P>
Prior to Apache version 1.3.6, <CODE>SIGPIPE</CODE> was handled by Apache. Currently Apache is not handling SIGPIPE anymore and
mod_perl takes care of it.

<P>
Under mod_perl, <CODE>$r-&gt;print</CODE> (or just <CODE>print())</CODE> returns a <EM>true</EM>
value on success, a <EM>false</EM> value on failure. The latter usually happens when the connection is broken.

<P>
If you want a similar to the old <CODE>SIGPIPE</CODE> behaviour (as it was before Apache version 1.3.6), add the following
configuration directive:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlFixupHandler Apache::SIG</pre>
        </td>
	    
      </tr>
    </table>
    <P>
When Apache's <CODE>SIGPIPE</CODE> handler is used, Perl may be left in the middle of it's eval context,
causing bizarre errors during subsequent requests are handled by that
child. When <CODE>Apache::SIG</CODE> is used, it installs a different <CODE>SIGPIPE</CODE> handler which rewinds the context to make sure Perl is back to normal
state, preventing these bizarre errors.

<P>
But in general case, you don't need to use the above setting.

<P>
If you use this setting and you would like to log when a request was
cancelled by a SIGPIPE in your Apache <EM>access_log</EM>, you must define a custom <CODE>LogFormat</CODE> in your <EM>httpd.conf</EM>, like so:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlFixupHandler Apache::SIG
  LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %s %b %{SIGPIPE}e&quot;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If the server has noticed that the request was cancelled via a
<CODE>SIGPIPE</CODE>, then the log line will end with <CODE>1</CODE>, otherwise it will just be a dash. e.g.:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  127.0.0.1 - - [09/Jan/2001:10:27:15 +0100] 
  &quot;GET /perl/stopping_detector.pl HTTP/1.0&quot; 200 16 1
  127.0.0.1 - - [09/Jan/2001:10:28:18 +0100] 
  &quot;GET /perl/test.pl HTTP/1.0&quot;              200 10 -</pre>
        </td>
	    
      </tr>
    </table>
    <P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Detecting_Aborted_Connections">Detecting Aborted Connections</A></H2></CENTER>
<P>
Let's use the knowledge we have acquired to trace the execution of the code
and watch all the events as they happen. 

<P>
Let's take a little script that obviously <EM>"hangs"</EM> the server process:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  stopping_detector.pl
  --------------------
  my $r = shift;
  $r-&gt;send_http_header('text/plain');
  
  print &quot;PID = $$\n&quot;;
  $r-&gt;rflush;
  
  while(1){
    $i++;
    sleep 1;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The script gets a request object <CODE>$r</CODE> by <CODE>shift()ing</CODE> it from the <CODE>@_</CODE>
argument list passed by the <CODE>handler()</CODE> subroutine. (This magic
is done by <CODE>Apache::Registry</CODE>). Then the script sends a <CODE>Content-type</CODE>
header, telling the client that we are going to send a plain text as a
response.

<P>
Next the script prints out a single line telling us the id of the process
that handles this request, which we need to know in order to run the
tracing utility. Then we flush Apache's buffer. (If we don't flush the
buffer we will never see this short information printed. That's because our
output is shorter than the buffer size and the script intentionally hangs,
so the buffer won't be auto-flushed as the script hangs at the end.)

<P>
Then we enter an infinite <CODE>while(1)</CODE> loop, which just increments a dummy variable and sleeps for a second.

<P>
Running <CODE>strace -p PID</CODE>, where <EM>PID</EM> is the process ID as printed to the browser, we see the following output
printed every second:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  SYS_175(0, 0xbffff41c, 0xbffff39c, 0x8, 0) = 0
  SYS_174(0x11, 0, 0xbffff1a0, 0x8, 0x11)    = 0
  SYS_175(0x2, 0xbffff39c, 0, 0x8, 0x2)      = 0
  nanosleep(0xbffff308, 0xbffff308, 
            0x401a61b4, 0xbffff308, 0xbffff41c) = 0
  time([941281947])                     = 941281947
  time([941281947])                     = 941281947</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Let's leave <CODE>strace</CODE> running and press the <STRONG>STOP</STRONG> button. Did anything change? No, the same system calls trace is printed
every second. Which means that Apache didn't detect the broken connection.

<P>
Now we are going to write the <CODE>\0</CODE> (NULL) character to the client in attempt to detect the broken connection
as close as possible to the time the <STRONG>Stop</STRONG> button is pressed at. Therefore we modify the loop code in the following
way:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  while(1){
    $r-&gt;print(&quot;\0&quot;);
    last if $r-&gt;connection-&gt;aborted;
    $i++;
    sleep 1;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We add a <CODE>print()</CODE> statement to print a NULL character and then
we check whether the connection was aborted with help of the
<CODE>$r-&gt;connection-&gt;aborted</CODE> method. If the connection is broken, we break out of the loop.

<P>
We run this script and strace on it as before, but we see that it still
doesn't work. The trouble is we aren't flushing the buffer, which leaves
the characters in the buffer and they won't be printed before the buffer
will get full and will be autoflushed. Since we want to attempt to write to
the connection pipe all the time, after printing the NULL, we add
$r-&gt;rflush(). Here is a new version of the code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  stopping_detector2.pl
  ---------------------
  my $r = shift;
  $r-&gt;send_http_header('text/plain');
  
  print &quot;PID = $$\n&quot;;
  $r-&gt;rflush;
  
  while(1){
    $r-&gt;print(&quot;\0&quot;);
    $r-&gt;rflush;
  
    last if $r-&gt;connection-&gt;aborted;
  
    $i++;
    sleep 1;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
After starting the <CODE>strace</CODE> utility on the running process as we did before and pressing the <STRONG>Stop</STRONG> button, we have seen the following output.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  SYS_175(0, 0xbffff41c, 0xbffff39c, 0x8, 0) = 0
  SYS_174(0x11, 0, 0xbffff1a0, 0x8, 0x11) = 0
  SYS_175(0x2, 0xbffff39c, 0, 0x8, 0x2)   = 0
  nanosleep(0xbffff308, 0xbffff308, 0x401a61b4, 0xbffff308, 0xbffff41c) = 0
  time([941284358])                       = 941284358
  write(4, &quot;\0&quot;, 1)                       = -1 EPIPE (Broken pipe)
  --- SIGPIPE (Broken pipe) ---
  select(5, [4], NULL, NULL, {0, 0})      = 1 (in [4], left {0, 0})
  time(NULL)                              = 941284358
  write(17, &quot;127.0.0.1 - - [30/Oct/1999:13:52&quot;..., 81) = 81
  gettimeofday({941284359, 39113}, NULL)  = 0
  times({tms_utime=9, tms_stime=8, tms_cutime=0, tms_cstime=0}) = 41551400
  close(4)                                = 0
  SYS_174(0xa, 0xbffff4e0, 0xbffff454, 0x8, 0xa) = 0
  SYS_174(0xe, 0xbffff46c, 0xbffff3e0, 0x8, 0xe) = 0
  fcntl(18, F_SETLKW, {type=F_WRLCK, whence=SEEK_SET, start=0, len=0}</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Apache detects the broken pipe as you see from this snippet:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  write(4, &quot;\0&quot;, 1)                       = -1 EPIPE (Broken pipe)
  --- SIGPIPE (Broken pipe) ---</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Then it stops the script and does all the cleanup work, like access
logging:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  write(17, &quot;127.0.0.1 - - [30/Oct/1999:13:52&quot;..., 81) = 81</pre>
        </td>
	    
      </tr>
    </table>
    <P>
where 17 is a file descriptor of the opened <EM>access_log</EM> file

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="The_Importance_of_Cleanup_Code">The Importance of Cleanup Code</A></H2></CENTER>
<P>
Cleanup code is a critical issue with aborted scripts.

<P>
What happens to locked resources if there are any? Will they be freed or
not? If not, scripts using these resources and the same locking scheme will
hang, waiting for them to be freed.

<P>
First let's go one step back and recall what are the problems and solutions
for this issue under mod_cgi.

<P>
Under mod_cgi the resource locking issue is a problem only if you happened
to create external lock files and and use them for lock indication, instead
of using <CODE>flock().</CODE> If the script running under mod_cgi is
aborted between the lock and the unlock code, and you didn't bother to
write cleanup code to remove old dead locks then you are in big trouble.

<P>
The solution is to use an <CODE>END</CODE> block to place the cleanup code in:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  END {
    # some code that ensures that locks are removed
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
When the script is aborted, Apache will run the <CODE>END</CODE> blocks.

<P>
If you use <CODE>flock()</CODE> things are much simpler, since all opened files will be closed when the
script exits. When the file is closed, the lock is removed as well--all the
locked resources get freed. There are systems where <CODE>flock(2)</CODE>
is unavailable, and for those you can use Perl's emulation of this
function.

<P>
With mod_perl things can be more complex when you use global variables as a
filehandlers. Because the processes don't exit after processing a request,
files won't be closed unless you explicitly <CODE>close()</CODE> them or
reopen with the <CODE>open()</CODE> call, which first closes a file. Let's
see what problems we might encounter, and possible solutions for them.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="Critical_Section">Critical Section</A></H3></CENTER>
<P>
First we want to make a little detour to discuss the <EM>"critical
section"</EM> issue.

<P>
Let's start with a resource locking scheme. A schematic representation of a
proper locking technique is as follows:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  1. lock a resource
     &lt;critical section starts&gt;
  2. do something with the resource
     &lt;critical section ends&gt;
  3. unlock the resource</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If the locking is exclusive, only one process can hold the resource at any
given time, which means that all the other processes will have to wait,
therefore the code between the locking and unlocking functions can become a
service bottleneck. That's why this code section is called critical and
once started it should be finished as soon as possible.

<P>
Even if you use a shared locking scheme, where many processes are allowed
to concurrently access the resource, if there are processes that sometimes
want to get an exclusive lock it's also important to keep the critical
section as short as possible.

<P>
The next example uses a shared lock, but has a poorly-designed critical
section:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  critical_section_sh.pl
  -------------------
  use Fcntl qw(:flock);
  use Symbol;
  my $fh = gensym;
  
  open $fh, &quot;/tmp/foo&quot; or die $!;
  flock $fh, LOCK_SH;
    # start critical section
  
  seek $fh, 0, 0;
  my @lines = &lt;$fh&gt;;
  for(@lines){
    print if /foo/;
  }
  
    # end critical section
  close $fh; # close unlocks the file</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The code opens the file for reading, locks and rewinds it to the beginning,
reads all the lines from the file and prints out the lines that contain the
string <EM>'foo'</EM>.

<P>
The <CODE>gensym()</CODE> function imported by the <CODE>Symbol</CODE> module creates an anonymous glob and returns a reference to it. Such a glob
reference can be used as a file or directory handle. and therefore allows
using lexically scoped variables as filehandlers. <CODE>Fcntl</CODE> imports into the script's namespace file locking symbols like: <CODE>LOCK_SH</CODE>, <CODE>LOCK_EX</CODE>
and more. Refer to the <CODE>Fcntl</CODE> manpage for more information.

<P>
If the file the script reads is big, it'd take a relatively long time for
this code to complete. All this time the file remains open and locked.
While it's other processes may access this file for reading (shared lock),
the process that wants to modify the file (which requires an acquision of
the exclusive lock), will be blocked waiting for this section to complete.

<P>
We can optimize the critical section this way:

<P>
Once the file has been read, we have all the information we need from it.
In order to make the example simpler we've chosen to just print out the
matching lines. In reality the code might be much longer.

<P>
We don't need the file to be open while the loop executes, because we don't
access it inside the loop. If we close the file before we start the loop,
we will allow other processes to have an exclusive access to the file if
they need it, instead of blocking them for no reason.

<P>
In the following corrected version of the previous example, we only read
the content of the file during the critical section and process it
afterwards, without creating a possible bottleneck.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  critical_section_sh2.pl
  --------------------
  use Fcntl qw(:flock);
  use Symbol;
  my $fh = gensym;
  
  open $fh, &quot;/tmp/foo&quot; or die $!;
  flock $fh, LOCK_SH;
    # start critical section
  
  seek $fh, 0, 0;
  my @lines = &lt;$fh&gt;;
  
    # end critical section
  close $fh; # close unlocks the file
  
  for(@lines){
    print if /foo/;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Here is another similar example, but now it uses an exclusive lock. The
script reads in a file and writes it back, prepending a number of new text
lines to the head of the file.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  critical_section_ex.pl
  --------------------
  use Fcntl qw(:flock);
  use Symbol;
  my $fh = gensym;
  
  open $fh, &quot;+&gt;&gt;/tmp/foo&quot; or die $!;
  flock $fh, LOCK_EX;
  
    # start critical section
  seek $fh, 0, 0;
  my @add_lines =
    (
     qq{Complete documentation for Perl, including FAQ lists,\n},
     qq{should be found on this system using `man perl' or\n},
     qq{`perldoc perl'. If you have access to the Internet, point\n},
     qq{your browser at <A HREF="http://www.perl.com/">http://www.perl.com/</A>, the Perl Home Page.\n},
    );
  
  my @lines = (@add_lines, &lt;$fh&gt;);
  seek $fh, 0, 0;
  truncate $fh, 0;
  print $fh @lines;
    # end critical section
  
  close $fh; # close unlocks the file</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Since we want to read the file, modify and write it back, without anyone
else changing it on the way, we open it for read and write with the help of <EM>+&gt;&gt;</EM> and lock it with an exclusive lock. You cannot safely accomplish this task
by opening the file first for read and then reopening for write, since
another process might change the file between the two events. (You could
get away with <EM>+&lt;</EM> as well, please refer to the <EM>perlfunc</EM> manpage for more information about the <CODE>open()</CODE> function.)

<P>
Next, the code prepares the lines of text it wants to prepend to the head
of the file, and assigns them and the content of the file to the
<CODE>@lines</CODE> array. Now we have our data ready to be written back to the file, so we
<CODE>seek()</CODE> to the start of the file and <CODE>truncate()</CODE> it
to zero size. In our example the file always grows, so in this case there
is no need to truncate it, but if there was a chance that the file might
shrink then truncating would be necessary. However it's good practice to
always use <CODE>truncate(),</CODE> as you never know what changes your
code might undergo in the future. The <CODE>truncate()</CODE> operation
does not carry any significant performance penalty. Finally we write the
data back to the file and close it, which unlocks it as well.

<P>
Did you notice that we created the text lines to be prepended as close to
the place of usage as possible? This complies with good
<EM>"locality of code"</EM> style, but it makes the critical section longer. In such cases you should
sacrifice style, in order to make the critical section as short as
possible. An improved version of this script with a shorter critical
section looks like this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  critical_section_ex2.pl
  --------------------
  use Fcntl qw(:flock);
  use Symbol;
  
  my @lines =
    (
     qq{Complete documentation for Perl, including FAQ lists,\n},
     qq{should be found on this system using `man perl' or\n},
     qq{`perldoc perl'. If you have access to the Internet, point\n},
     qq{your browser at <A HREF="http://www.perl.com/">http://www.perl.com/</A>, the Perl Home Page.\n},
    );
  
  my $fh = gensym;
  open $fh, &quot;+&gt;&gt;/tmp/foo&quot; or die $!;
  flock $fh, LOCK_EX;
    # start critical section
  
  seek $fh, 0, 0;
  push @lines, &lt;$fh&gt;;
  
  seek $fh, 0, 0;
  truncate $fh, 0;
  print $fh @lines;
  
    # end critical section
  close $fh; # close unlocks the file</pre>
        </td>
	    
      </tr>
    </table>
    <P>
There are two important differences. First, we prepare the text lines to be
prepended <EM>before</EM> the file is locked. Second, instead of creating a new array and copying
lines from one array to another, we append the file directly to the <CODE>@lines</CODE> array.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="Safe_Resource_Locking_and_Cleanu">Safe Resource Locking and Cleanup Code</A></H3></CENTER>
<P>
Let's get back to the main issue of this section, which is safe resource
locking.

<P>
Unless you use the <CODE>Apache::PerlRun</CODE> handler that does the cleanup for you, if you don't make a habit of closing
all the files that you open--in some cases you will encounter lots of
problems. If you open a file but don't close it, you may have file
descriptor leakage. Since the number of file descriptors available to you
is finite, at some point you may run out of them and your service will
fail. This is bad, but you can live with it until you run out of file
descriptors (which will happen much faster on a heavily used server).

<P>
You can use system utilities to observe the opened and locked files, as
well as the processes that has opened (and locked) the files. On FreeBSD
you would use the <CODE>fstat(1)</CODE> utility. On many other UN*X flavors
the <CODE>lsof(1)</CODE> utility is available.

<P>
But this is nothing compared to the trouble you will give yourself if the
code terminates and the file stays locked. Any other process requesting a
lock on the same file (or resource) will wait indefinitely for it to become
unlocked. Since this will not happen until the server reboots, all these
processes trying to use this resource will hang.

<P>
Here is an example of such a terrible mistake:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  flock.pl
  --------
  use Fcntl qw(:flock);
  open IN, &quot;+&gt;&gt;filename&quot; or die &quot;$!&quot;;
  flock IN, LOCK_EX;
    # do something
    # quit without closing and unlocking the file</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Is this safe code? No - we forgot to close the file. So let's add the
<CODE>close():</CODE>

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  flock2.pl
  ---------
  use Fcntl qw(:flock);
  open IN, &quot;+&gt;&gt;filename&quot; or die &quot;$!&quot;;
  flock IN, LOCK_EX;
    # do something
  close IN;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Is it safe code now? Unfortunately it is not. There is a chance that the
user may abort the request (for example by pressing his browser's
<CODE>Stop</CODE> or <CODE>Reload</CODE> buttons) during the critical section. The script will be aborted before it
has had a chance to <CODE>close()</CODE> the file, which is just as bad as
if we forgot to close it.

<P>
In fact if the same process will run the same code again, an
<CODE>open()</CODE> call will close the file first, which will unlock the
resource. This is because <CODE>IN</CODE> is a global variable. But it's quite possible that the process that created
the lock, will not serve the same request for a while, since it would be
busy serving other requests. So relying on it to reopen the file is a bad
idea.

<P>
This problem happens <STRONG>only</STRONG> if you use global variables as file handles. The following example has the
same problem.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  flock3.pl
  ---------
  use Fcntl qw(:flock);
  use Symbol ();
  use vars qw($fh);
  $fh = Symbol::gensym();
  open $fh, &quot;+&gt;&gt;filename&quot; or die &quot;$!&quot;;
  flock $fh, LOCK_EX;
    # do something
  close $fh;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
<CODE>$fh</CODE> is still a global variable and therefore the code using it suffers from the
same problem.

<P>
The simplest solution to this problem is to always use lexically scoped
variables (created with <CODE>my()).</CODE> Whether script gets aborted
before <CODE>close()</CODE> is called or you forgot the use
<CODE>close()</CODE> the lexically scoped variable will always go out of
scope and therefore if the file was locked it will be unlocked. Here is a
good version of the code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  flock4.pl
  ---------
  use Fcntl qw(:flock);
  use Symbol ();
  my $fh = Symbol::gensym();
  open $fh, &quot;+&gt;&gt;filename&quot; or die &quot;$!&quot;;
  flock $fh, LOCK_EX;
    # do something
  close $fh;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Please don't conclude from this example that you don't have to close files
anymore, since they will be automatically closed for you. It's a bad style
and should be avoided.

<P>
mod_perl comes with its own implementation of <CODE>gensym(),</CODE> so you
don't even need to load the Symbol module in order to use this function. In
mod_perl this function resides in the <A HREF="#item_Apache">Apache</A> package. For example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use Apache;
  my $fh = Apache::gensym();
  open $fh, &quot;+&gt;&gt;filename&quot; or die &quot;$!&quot;;
  ...</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If you insist on using the file globs, at least make sure that you
<CODE>local()'ize</CODE> these, and then if the flow of the code is
interrupted before <CODE>close()</CODE> was called the filehandle will be
automatically closed, since the <CODE>local()'ized</CODE> variable will go
out of the scope. The following example shows that the file is indeed
closed even when there is no <CODE>close():</CODE>

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  /tmp/io.pl
  --------------
  #!/usr/bin/perl
  # /dev/null so strace output is more readable
  open my $fh, &quot;&gt;/dev/null&quot;;
  select $fh;
  $| = 1;
  {
    print &quot;enter&quot;;
    local *FH;
    open FH, $0;
    print &quot;leave&quot;
  }
  print &quot;done&quot;;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This simple script opens the <EM>/dev/null</EM> and tells Perl to send all the STDOUT there, which is also made unbuffered.
Then the block is created in which the <CODE>FH</CODE> file glob is localized. Then it's used to open the source code of the
script (which resides in <CODE>$0</CODE>). In order to separate event of entering the block scope and leaving it,
the debug print statements are used. Now let's run the script under
<CODE>strace(1),</CODE> which proves once again to be very useful in the
tool bag of the mod_perl programmer:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % strace /tmp/io.pl
  write(3, &quot;enter&quot;, 5)                    = 5
  -&gt; open(&quot;/tmp/io.pl&quot;, O_RDONLY) = 4
  fstat(4, {st_mode=S_ISGID|S_ISVTX|0401, st_size=0, ...}) = 0
  fcntl(4, F_SETFD, FD_CLOEXEC)           = 0
  write(3, &quot;leave&quot;, 5)                    = 5
  -&gt; close(4)                                = 0
  write(3, &quot;done&quot;, 4)                     = 4</pre>
        </td>
	    
      </tr>
    </table>
    <P>
So you can see that <EM>/tmp/io.pl</EM> is actually <CODE>close()'d.</CODE>

<P>
Under Perl version 5.6 <CODE>Symbol.pm</CODE>-like functionality is a built-in feature, so you can do:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  open my $fh, &quot;&gt;/tmp/foo&quot; or die $!;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
and <CODE>$fh</CODE> will be automatically vivified as a valid filehandle, so you don't need to
use the <CODE>Symbol</CODE> module anymore, if backward compatibility is not a requirement.

<P>
You can also use the <CODE>IO::*</CODE> modules, such as <CODE>IO::File</CODE> or
<CODE>IO::Dir</CODE>. These are much bigger than the &lt;Symbol&gt; module, and worth using for files or directories only if you are
already using them for the other features which they provide. As a matter
of fact, these modules use the <CODE>Symbol</CODE> module themselves. Here is an example of their usage:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use IO::File;
  use IO::Dir;
  my $fh = IO::File-&gt;new(&quot;&gt;filename&quot;);
  my $dh = IO::Dir-&gt;new(&quot;dirname&quot;);</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If you still have to use global filehandles, there are a few approaches we
can take to solving the locking problem.

<P>
If you are running under <CODE>Apache::Registry</CODE> and friends, the <CODE>END</CODE>
block will perform the cleanup work for you. You might use <CODE>END</CODE> in the same way for scripts running under mod_cgi, or in plain Perl
scripts. Just add the cleanup code to this block and you are safe.

<P>
For example if you work with dbm files just like with locking it's
important to flush the dbm buffers, by calling a <CODE>sync()</CODE>
method:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  END{
    # make sure that the DB is flushed
     $dbh-&gt;sync();
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Normally the <CODE>END</CODE> blocks will not be executed after the completion of a request, but only
when an Apache child process exits, then if you are writing your own
handlers you will need to use the <CODE>register_cleanup()</CODE> function
to supply cleanup code similar to that used in <CODE>END</CODE> blocks instead of using <CODE>END</CODE> blocks.  

<P>
Under mod_perl, the above will work only for <CODE>Apache::Registry</CODE>
scripts. Otherwise execution of the <CODE>END</CODE> block will be postponed until the process terminates. If you write a
handler in the Perl API use the <CODE>register_cleanup()</CODE> method instead. It accepts a reference to a subroutine as an argument:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  $r-&gt;register_cleanup(sub { $dbh-&gt;sync() });</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Even better would be to check whether the client connection has been
aborted. If you don't check, the cleanup code will always be executed and
for normally terminated scripts this may not be what you want:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  $r-&gt;register_cleanup(
    # make sure that the DB is flushed
    sub{ 
      $dbh-&gt;sync() if Apache-&gt;request-&gt;connection-&gt;aborted();
    }
  );</pre>
        </td>
	    
      </tr>
    </table>
    <P>
So in the case of <CODE>END</CODE> block usage you would use:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  END{
    # make sure that the DB is flushed
    $dbh-&gt;sync() if Apache-&gt;request-&gt;connection-&gt;aborted();
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Note that if you use <CODE>register_cleanup()</CODE> it should be called at the beginning of the script, or as soon as the
variables you want to use in this code become available. If you use it at
the end of the script, and the script happens to be aborted before this
code is reached, there will be no cleanup performed.

<P>
For example <CODE>CGI.pm</CODE> registers the cleanup subroutine in its <CODE>new()</CODE> method:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  sub new {
    # code snipped
    if ($MOD_PERL) {   
        Apache-&gt;request-&gt;register_cleanup(\&amp;CGI::_reset_globals);
        undef $NPH;
    }
    # more code snipped
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
There is another way to register a section of cleanup code for Perl API
handlers. You may use <CODE>PerlCleanupHandler</CODE> in the configuration file, like this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  &lt;Location /foo&gt;
    SetHandler perl-script
    PerlHandler        Apache::MyModule
    PerlCleanupHandler Apache::MyModule::cleanup()
    Options ExecCGI
  &lt;/Location&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
<CODE>Apache::MyModule::cleanup()</CODE> performs the cleanup, obviously.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Handling_Server_Timeout_Cases_an">Handling Server Timeout Cases and Working with $SIG{ALRM}</A></H1></CENTER>
<P>
A similar situation to <A HREF="././debug.html#Handling_the_User_pressed_Stop_">Pressed Stop button disease</A> happens when the browser times out the connection (is it about 2 minutes?).
There are cases when your script is about to perform a very long operation
and there is a chance that its duration will be longer than the client's
timeout. One example is database interaction, where the DB engine hangs or
needs a long time to return the results. If this is the case, use <CODE>$SIG{ALRM}</CODE> to prevent the timeouts:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    $timeout = 10; # seconds
  eval {
    local $SIG{ALRM} =
        sub { die &quot;Sorry timed out. Please try again\n&quot; };
    alarm $timeout;
    ... db stuff ...
    alarm 0;
  };
  
  die $@ if $@;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
It was recently discovered that <CODE>local $SIG{'ALRM'}</CODE> does not restore the original underlying C handler. This was fixed in
mod_perl 1.19_01 (<A HREF="././download.html#mod_perl">CVS version</A>). As a matter of fact none of the
<CODE>local $SIG{FOO}</CODE> signals restores the original C handler - read
<A HREF="././debug.html#Debugging_Signal_Handlers_SIG_">Debugging Signal Handlers ($SIG{FOO})</A> for a debug technique and a possible workaround.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Looking_inside_the_server">Looking inside the server</A></H1></CENTER>
<P>
Your server is up and running, but something appears to be wrong. You want
to see the numbers to tune your code or server configuration. You just want
to know what's really going on inside the server.

<P>
How do you do it?

<P>
There are a few tools that allow you to look inside the server. 

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Apache_Status_Embedded_Inter">Apache::Status -- Embedded Interpreter Status Information</A></H2></CENTER>
<P>
This is a very useful module. It lets you watch what happens to the Perl
parts of the server. You can see the size of all subroutines and variables,
variable dumps, lexical information, OPcode trees, and more.

<P>
You shouldn't use it on production server as it adds quite a bit of
overhead for each request.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="Minimal_Configuration">Minimal Configuration</A></H3></CENTER>
<P>
This configuration enables the <CODE>Apache::Status</CODE> module with its minimum feature set. Add this to <EM>httpd.conf</EM>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  &lt;Location /perl-status&gt;
    SetHandler perl-script
    PerlHandler Apache::Status
    order deny,allow
    #deny from all
    #allow from 
  &lt;/Location&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If you are going to use <CODE>Apache::Status</CODE> it's important to put it as the first module in the start-up file, or in <EM>httpd.conf</EM>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  # startup.pl
  use Apache::Status ();
  use Apache::Registry ();
  use Apache::DBI ();</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If you don't put <CODE>Apache::Status</CODE> before <CODE>Apache::DBI</CODE>, you won't get the <CODE>Apache::DBI</CODE> menu entry in the status. For more about
<CODE>Apache::DBI</CODE> see <A HREF="././performance.html#Persistent_DB_Connections">Persistent DB Connections</A>.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="Extended_Configuration">Extended Configuration</A></H3></CENTER>
<P>
There are several variables which you can use to modify the behaviour of <CODE>Apache::Status</CODE>.

<UL>
<P><LI><STRONG><A NAME="item_PerlSetVar">PerlSetVar StatusOptionsAll On</A></STRONG>
<P>
This single directive will enable all of the options described below.

<P><LI><STRONG><A NAME="item_PerlSetVar">PerlSetVar StatusDumper On</A></STRONG>
<P>
When you are browsing symbol tables, you can view the values of your
arrays, hashes and scalars with <CODE>Data::Dumper</CODE>.

<P><LI><STRONG><A NAME="item_PerlSetVar">PerlSetVar StatusPeek On</A></STRONG>
<P>
With this option On and the <CODE>Apache::Peek</CODE> module installed, functions and variables can be viewed in <CODE>Devel::Peek</CODE> style.

<P><LI><STRONG><A NAME="item_PerlSetVar">PerlSetVar StatusLexInfo On</A></STRONG>
<P>
With this option On and the <CODE>B::LexInfo</CODE> module installed, subroutine lexical variable information can be viewed.

<P><LI><STRONG><A NAME="item_PerlSetVar">PerlSetVar StatusDeparse On</A></STRONG>
<P>
With this option On and <CODE>B::Deparse</CODE> version 0.59 or higher (included in Perl 5.005_59+), subroutines can be
``deparsed''.

<P>
Options can be passed to <CODE>B::Deparse::new</CODE> like so:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlSetVar StatusDeparseOptions &quot;-p -sC&quot;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
See the <CODE>B::Deparse</CODE> manpage for details.

<P><LI><STRONG><A NAME="item_PerlSetVar">PerlSetVar StatusTerse On</A></STRONG>
<P>
With this option On, text-based op tree graphs of subroutines can be
displayed, thanks to <CODE>B::Terse</CODE>.

<P><LI><STRONG><A NAME="item_PerlSetVar">PerlSetVar StatusTerseSize On</A></STRONG>
<P>
With this option On and the <CODE>B::TerseSize</CODE> module installed, text-based op tree graphs of subroutines and their size
can be displayed. See the <CODE>B::TerseSize</CODE> docs for more info.

<P><LI><STRONG><A NAME="item_PerlSetVar">PerlSetVar StatusTerseSizeMainSummary On</A></STRONG>
<P>
With this option On and the <CODE>B::TerseSize</CODE> module installed, ``Memory Usage'' will be added to the <CODE>Apache::Status</CODE> main menu. This option is disabled by default, as it can be rather cpu
intensive to summarize memory usage for the entire server. It is strongly
suggested that this option only be used with a development server running
in -X mode, as the results will be cached.

<P>
Remember to preload <CODE>B::TerseSize</CODE> with: 

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlModule B::Terse</pre>
        </td>
	    
      </tr>
    </table>
    <P><LI><STRONG><A NAME="item_PerlSetVar">PerlSetVar StatusGraph</A></STRONG>
<P>
When <CODE>StatusDumper</CODE> (see above) is enabled, another link <EM>"OP Tree
Graph"</EM> will be present with the dump if this configuration variable is set to On.

<P>
This requires the B module (part of the Perl compiler kit) and the
<CODE>B::Graph</CODE> module version 0.03 or higher to be installed along with the `dot' program.
Dot is part of the graph visualization toolkit from AT&amp;T: <A
HREF="http://www.research.att.com/sw/tools/graphviz/.">http://www.research.att.com/sw/tools/graphviz/.</A>


<P>
WARNING: Some graphs may produce very large images, and some graphs may
produce no image if <CODE>B::Graph</CODE>'s output is incorrect.

</UL>
<P>
There is more information about <CODE>Apache::Status</CODE> in its manpage.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="Usage">Usage</A></H3></CENTER>
<P>
Assuming that your mod_perl server listens on port 81, fetch <A
HREF="http://www.myserver.com:81/perl-status">http://www.myserver.com:81/perl-status</A>


<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  Embedded Perl version 5.00502 for Apache/1.3.2 (Unix) mod_perl/1.16 
  process 187138, running since Thu Nov 19 09:50:33 1998</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Below all the sections are links when you view them through <EM>/perl-status</EM>



<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  Signal Handlers
  Enabled mod_perl Hooks
  PerlRequire'd Files
  Environment
  Perl Section Configuration
  Loaded Modules
  Perl Configuration
  ISA Tree
  Inheritance Tree
  Compiled Registry Scripts
  Symbol Table Dump</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Let's follow, for example, <CODE>PerlRequire</CODE>'d Files. We see:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlRequire                   Location
  /home/perl/apache-startup.pl  /home/perl/apache-startup.pl</pre>
        </td>
	    
      </tr>
    </table>
    <P>
From some menus you can move deeper to peek into the internals of the
server, to see the values of the global variables in the packages, to see
the cached scripts and modules, and much more. Just click around...

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="Compiled_Registry_Scripts_sectio">Compiled Registry Scripts section seems to be empty.</A></H3></CENTER>
<P>
Sometimes when you fetch <EM>/perl-status</EM> and look at the <STRONG>Compiled
Registry Scripts</STRONG> you see no listing of scripts at all. This is correct: <CODE>Apache::Status</CODE> shows the registry scripts compiled in the httpd child which is serving
your request for <EM>/perl-status</EM>. If the child has not yet compiled the script you are asking for,
<EM>/perl-status</EM> will just show you the main menu.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="mod_status">mod_status</A></H2></CENTER>
<P>
The Status module allows a server administrator to find out how well the
server is performing. An HTML page is presented that gives the current
server statistics in an easily readable form. If required, given a
compatible browser this page can be automatically refreshed. Another page
gives a simple machine-readable list of the current server state.

<P>
This Apache module is written in C. It is compiled by default, so all you
have to do to use it is enable it in your configuration file:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  &lt;Location /status&gt;
    SetHandler server-status
  &lt;/Location&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
For security reasons you will probably want to limit access to it. If you
have installed Apache according to the instructions you will find a
prepared configuration section in <EM>httpd.conf</EM>: to enable use of the mod_status module, just uncomment it.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  ExtendedStatus On
  &lt;Location /status&gt;
    SetHandler server-status
    order deny,allow
    deny from all
    allow from localhost
  &lt;/Location&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
You can now access server statistics by using a Web browser to access the
page <A HREF="http://localhost/status">http://localhost/status</A> (as long
as your server recognizes localhost:).

<P>
The details given by mod_status are:

<UL>
<P><LI><STRONG><A NAME="item_The">The number of children serving requests</A></STRONG>
<P><LI><STRONG><A NAME="item_The">The number of idle children</A></STRONG>
<P><LI><STRONG><A NAME="item_The">The status of each child, the number of requests that child
has performed and the total number of bytes served by the child</A></STRONG>
<P><LI><STRONG><A NAME="item_A">A total number of accesses and the total bytes served</A></STRONG>
<P><LI><STRONG><A NAME="item_The">The time the server was last started/restarted and how long it has
been running for</A></STRONG>
<P><LI><STRONG><A NAME="item_Averages">Averages giving the number of requests per second, the number
of bytes served per second and the average number of bytes per request</A></STRONG>
<P><LI><STRONG><A NAME="item_The">The current percentage CPU used by each child and in total by
Apache</A></STRONG>
<P><LI><STRONG><A NAME="item_The">The current hosts and requests being processed</A></STRONG>
</UL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Apache_VMonitor_Visual_Syste">Apache::VMonitor -- Visual System and Apache Server Monitor</A></H2></CENTER>
<P>
This module is covered in the section ``<A HREF="././modules.html#Apache_VMonitor_Visual_Syste">Apache::*  Modules</A>''

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Sometimes_My_Script_Works_Somet">Sometimes My Script Works, Sometimes It Does Not</A></H1></CENTER>
<P>
See <A HREF="././porting.html#Sometimes_it_Works_Sometimes_it">Sometimes it Works Sometimes it does Not</A>



<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Code_Debug">Code Debug</A></H1></CENTER>
<P>
When the code doesn't perform as expected, either never or just sometimes,
we say that the code needs debugging. There are several levels of debugging
complexity.

<P>
The basic level is when Perl terminates the program during the compilation
phase, before it tries to run the resulting byte-code. This usually happens
because there are syntax errors in the code, or perhaps a module is
missing. Sometimes it takes quite an effort to solve these problems, since
code that uses Apache CORE modules generally won't compile when executed
from the shell. We will learn how to solve syntax problems in mod_perl code
quite easily.

<P>
Once the program compiles and begins to run, there might be logical
problems, when the program doesn't do what you thought you had programmed
it to do. These are somewhat harder to solve, especially when there is a
lot of code to be inspected and reviewed, but it's just a matter of time.
Perl can help a lot, for example to locate typos, when we enable warnings.
For example, if you wanted to compare two numbers, but you omitted the
second '=' character so that you had something like <CODE>if $yes = 1</CODE> instead of <CODE>if $yes == 1</CODE>, it warns us about the missing '='.

<P>
The next level is when the program does what it's expected to do most of
the time, but occasionally misbehaves. Often you find that
<CODE>print()</CODE> statements or the Perl debugger can help, but
inspection of the code generally doesn't. Often it's quite easy to debug
with <CODE>print(),</CODE> but sometimes typing the debug messages can
become very tedious. That's where the Perl debugger comes into its own.

<P>
While <CODE>print()</CODE> statements always work, running the perl
debugger for CGI scripts might be quite a challenge. But with the right
knowledge and tools handy the debug process becomes much easier.
Unfortunately there is no one easy way to debug your programs, as the
debugging depends entirely on your code. It can be a nightmare to debug
really complex code, but as your style matures you can learn ways to write
simpler code that is easier to debug. You will probably find that when you
write simpler clearer code it does not need so much debugging in the first
place.

<P>
One of the most difficult cases to debug, is when the process just
terminates in the middle of processing a request and dumps core. Often when
there is a bug the program tries to access a memory area that doesn't
belong to it. The operating system halts the process, tidies up and dumps
core (it creates a file called <EM>core</EM> in the current directory of the process that was running). This is
something that you rarely see with plain perl scripts, but it can easily
happen if you use modules written in <EM>C</EM> or <EM>C++</EM> and something goes wrong with them. Occasionally you will come across a bug
in mod_perl itself (mod_perl is written in C), that was in a deep slumber
before your code awakened it.

<P>
In the following sections we will go through in detail each of the problems
presented, thoroughly discuss them and present a few techniques to solve
them.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Locating_and_correcting_Syntax_E">Locating and correcting Syntax Errors</A></H2></CENTER>
<P>
While developing code we often make syntax mistakes, like forgetting to put
a comma in a list, or a semicolon at the end of a statement.

<P>
Even at the end of a {} block, where a semicolon is not required at the end
of the last statement, it may be better to put one in: there is a chance
that you will add more code later, and when you do you might forget to add
the now required semicolon. Similarly, more items might be added later to a
list; unlike many other languages, Perl has no problem when you end a list
with a redundant comma.

<P>
One approach to locating syntactically incorrect code is to execute the
script from the shell with the <EM>-c</EM> flag. This tells Perl to check the syntax but not to run the code
(actually, it will execute
<CODE>BEGIN</CODE>, <CODE>END</CODE> blocks, and <EM>use()</EM> calls, because these are considered as occurring outside the execution of
your program). (Note also that Perl 5.6.0 has introduced a new special
variable, <CODE>$^C</CODE>, which is set to true when perl is run with the <EM>-c</EM> flag; this provides an opportunity to have some further control over <CODE>BEGIN</CODE> and
<CODE>END</CODE> blocks during syntax checking.) Also it's a good idea to add the <CODE>-w</CODE> switch to enable warnings:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  perl -cw test.pl</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If there are errors in the code, Perl will report the errors, and tell you
at which line numbers in your script the errors were found.

<P>
The next step is to execute the script, since in addition to syntax errors
there may be run time errors. These are the errors that cause the <EM>"Internal Server Error"</EM> page when executed from a browser. With plain CGI scripts it's the same as
running plain Perl scripts -- just execute them and see that they work.

<P>
The whole thing is quite different with scripts that use <A HREF="#item_Apache_">Apache::*</A>
modules which can be used only from within the mod_perl server environment.
These scripts rely on other code, and an environment which isn't available
when you attempt to execute the script from the shell. There is no Apache
request object available to the code when it is executed from the shell.

<P>
If you have a problem when using <A HREF="#item_Apache_">Apache::*</A> modules, you can make a request to the script from a browser and watch the
errors and warnings as they are logged to the <EM>error_log</EM> file. Alternatively you can use the <CODE>Apache::FakeRequest</CODE> module.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Using_Apache_FakeRequest_to_Deb">Using Apache::FakeRequest to Debug Apache Perl Modules</A></H2></CENTER>
<P>
<CODE>Apache::FakeRequest</CODE> is used to set up an empty Apache request object that can be used for
debugging. The <CODE>Apache::FakeRequest</CODE>
methods just set internal variables with the same names as the methods and
return the value of the internal variables. Initial values for methods can
be specified when the object is created. The print method prints to STDOUT.

<P>
Subroutines for Apache constants are also defined so that you can use
<CODE>Apache::Constants</CODE> while debugging, although the values of the constants are hard-coded rather
than extracted from the Apache source code.

<P>
Let's write a very simple module, which prints <EM>"OK"</EM> to the client's browser:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  package Apache::Example;
  use Apache::Constants;
  
  sub handler{
    my $r = shift;
    $r-&gt;send_http_header('text/plain');
    print &quot;You are OK &quot;, $r-&gt;get_remote_host, &quot;\n&quot;;
    return OK;
  }
  
  1;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
You cannot debug this module unless you configure the server to run it, by
calling its handler from somewhere. So for example you could put in <EM>httpd.conf</EM>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  &lt;Location /ex&gt;
    SetHandler perl-script
    PerlHandler Apache::Example
  &lt;/Location&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Then after restarting the server you could start a browser, request the
location <A HREF="http://localhost/ex">http://localhost/ex</A> and examine
the output. Tedious, no?

<P>
But with the help of <CODE>Apache::FakeRequest</CODE> you can write a little script that will emulate a request and return the
output.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #!/usr/bin/perl</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use Apache::FakeRequest ();
  use Apache::Example ();
  
  my $r = Apache::FakeRequest-&gt;new('get_remote_host'=&gt;'www.foo.com');
  Apache::Example::handler($r);</pre>
        </td>
	    
      </tr>
    </table>
    <P>
when you execute the script from the command line, you will see the
following output:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  You are OK www.foo.com</pre>
        </td>
	    
      </tr>
    </table>
    <P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Finding_the_Line_Which_Triggered">Finding the Line Which Triggered the Error or Warning</A></H2></CENTER>
<P>
Perl has no problem with the line numbers and file names for modules that
are read from disk in the normal way, but modules that are compiled via
<CODE>eval()</CODE> such as <CODE>Apache::Registry</CODE> and <CODE>Apache::PerlRun</CODE>
sometimes with some versions of Perl get confused.

<P>
There is the Perl &lt;&lt;HEREDOC inside eval ``'' problem that confuses the Perl current linenumber
counter, newer Perls fix this. For older Perls compiling with the
experimental <STRONG>PERL_MARK_WHERE=1</STRONG>
should solve this.

<P>
There are compiler directives to reset its counter to some value that you
decide. You can always pepper your code with these to help you locate the
problem. At the beginning of the line you could write something of the
form:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #line nnn label</pre>
        </td>
	    
      </tr>
    </table>
    <P>
For example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #line 298 myscript.pl
  or 
  #line 890 some_label_to_be_used_in_the_error_message</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The '#' must be in the first column, so if you cut and paste from this text
you must remember to remove any leading white space.

<P>
The label is optional - the filename of the script will be used by default.
This directive sets the line number of the <STRONG>following</STRONG>
line, not the line the directive is on. You can use a little script to
stuff every N lines of your code with these directives, but then you will
have to remember to rerun this script every time you add or remove code
lines. The script:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #!/usr/bin/perl
  # Puts Perl line markers in a Perl program for debugging purposes.  
  # Also takes out old line markers.
  die &quot;No filename to process.\n&quot; unless @ARGV;
  my $filename = shift;
  my $lines = 100;
  open IN, $filename or die &quot;Cannot open file: $filename: $!\n&quot;;
  open OUT, &quot;&gt;$filename.marked&quot;
      or die &quot;Cannot open file: $filename.marked: $!\n&quot;;
  my $counter = 1;
  while (&lt;IN&gt;) {
    print OUT &quot;#line $counter\n&quot; unless $counter++ % $lines;
    next if /^#line /;
    print OUT $_;
  }
  close OUT;
  close IN;
  chmod 0755, &quot;$filename.marked&quot;;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Another way of narrowing down the area to be searched is to move most of
the code into a separate modules. This ensures that the line number will be
reported correctly.

<P>
To have a complete trace of calls add:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use Carp ();
  local $SIG{__WARN__} = \&amp;Carp::cluck;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Using_print_for_Debugging">Using print() for Debugging</A></H2></CENTER>
<P>
The universal debugging tool across nearly all platforms and programming
languages is <CODE>printf()</CODE> or the equivalent output function. This
can send data to the console, a file, an application window and so on. In
perl we generally use the <CODE>print()</CODE> function. With an idea of
where and when the bug is triggered, a developer can insert
<CODE>print()</CODE> statements in the source code to examine the value of
data at certain stages of execution.

<P>
However, it is rather difficult to anticipate all possible directions a
program might take and what data to suspect of causing trouble. In
addition, inline debugging code tends to add bloat and degrade the
performance of an application and can also make the code harder to read and
maintain. And you have to comment out or remove the debugging
<CODE>print()</CODE> calls when you think that you have solved the problem.
But if later you discover that you need to debug the same code again, you
need at best to uncomment the debugging code lines or, at worst, to write
them again from scratch.

<P>
Let's see a few examples where we use <CODE>print()</CODE> to debug some
problem. In one of my applications I wrote a function that returns the date
that was one week ago. Here it is:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  print &quot;Content-type: text/plain\r\n\r\n&quot;;
  
  print &quot;A week ago the date was &quot;,date_a_week_ago(),&quot;\n&quot;;
  
  # return a date one week ago as a string in format: MM/DD/YYYY
  ####################
  sub date_a_week_ago{
  
    my @month_len   = (31,28,31,30,31,30,31,31,30,31,30,31);
  
    my ($day,$month,$year) = (localtime)[3..5];
    for (my $j = 0; $j &lt; 7; $j++) {
  
      $day--;
      if ($day == 0) {
  
        $month--;
        if ($month == 0) {
          $year--;
          $month = 12;
        }
  
          # there are 29 days in February in a leap year
        $month_len[1] =  
          (($year % 4 or $year % 100 == 0) and $year % 400 )
        ? 28 : 29;
  
          # set $day to be the last day of the previous month 
        $day = $month_len[$month - 1]; 
  
      }   # end of if ($day == 0)
    }     # end of for ($i = 0;$i &lt; 7;$i++)
  
    return sprintf &quot;%02d/%02d/%04d&quot;,$month,$day,$year+1900;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This code is pretty straightforward. We get today's date and subtract one
from the value of the day we get, updating the month and the year on the
way if boundaries are being crossed (end of month, end of year). If we do
it seven times in loop then at the end we should get a date that was a week
ago.

<P>
Note that since <CODE>locatime()</CODE> returns the year as a value of
<CODE>current_four_digits_format_year-1900</CODE> (which means that we don't have a century boundary to worry about) then if
we are in the middle of the first week of the year 2000, the value of year
returned by <CODE>localtime()</CODE> will be <CODE>100</CODE> and not <CODE>0</CODE> as you might mistakenly assume. So when the code does <CODE>$year--</CODE> it becomes <CODE>99</CODE> and not
<CODE>-1</CODE>. At the end we add 1900 to get back the correct four-digit year format.
(This is all correct as long as you don't go to the years prior to 1900)

<P>
Also note that we have to account for leap years where there are 29 days in
February. For the other months we have prepared an array containing the
month lengths.

<P>
Now when we run this code and check the result, we see that something is
wrong. For example, if today is <CODE>10/23/1999</CODE> we expect the above code to print <CODE>10/16/1999</CODE>. In fact it prints <CODE>09/16/1999</CODE>, which means that we have lost a month. The above code is buggy!

<P>
Let's put a few debug <CODE>print()</CODE> statements in the code, near the
<CODE>$month</CODE> variable:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  sub date_a_week_ago{
  
    my @month_len   = (31,28,31,30,31,30,31,31,30,31,30,31);
  
    my ($day,$month,$year) = (localtime)[3..5];
    print &quot;[set] month : $month\n&quot;; # DEBUG
    for (my $j = 0; $j &lt; 7; $j++) {
  
      $day--;
      if ($day == 0) {
  
        $month--;
        if ($month == 0) {
          $year--;
          $month = 12;
        }
        print &quot;[loop $i] month : $month\n&quot;; # DEBUG
  
          # there are 29 days in February in a leap year
        $month_len[1] =  
          (($year % 4 or $year % 100 == 0) and $year % 400 )
        ? 28 : 29;
  
          # set $day to be the last day of the previous month 
        $day = $month_len[$month - 1]; 
  
      }   # end of if ($day == 0)
    }     # end of for ($i = 0;$i &lt; 7;$i++)
  
    return sprintf &quot;%02d/%02d/%04d&quot;,$month,$day,$year+1900;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
When we run it we see:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  [set] month : 9</pre>
        </td>
	    
      </tr>
    </table>
    <P>
It is supposed to be the number of the current month (<CODE>10</CODE>), but actually it is not. We have spotted a bug, since the only code that
sets the
<CODE>$month</CODE> variable consists of a call to <CODE>localtime().</CODE> So did we find a
bug in Perl? let's look at the manpage of the <CODE>localtime()</CODE>
function:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perldoc -f localtime
  
  Converts a time as returned by the time function to a 9-element
  array with the time analyzed for the local time zone.  Typically
  used as follows:</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    #  0    1    2     3     4    5     6     7     8
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime(time);</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  All array elements are numeric, and come straight out of a struct
  tm.  In particular this means that C&lt;$mon&gt; has the range C&lt;0..11&gt;
  and C&lt;$wday&gt; has the range C&lt;0..6&gt; with Sunday as day C&lt;0&gt;.  Also,
  C&lt;$year&gt; is the number of years since 1900, that is, C&lt;$year&gt; is
  C&lt;123&gt; in year 2023, and I&lt;not&gt; simply the last two digits of the
  year.  If you assume it is, then you create non-Y2K-compliant
  programs--and you wouldn't want to do that, would you?
  [more info snipped]</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Which reveals to us that if we want to count months from 1 to 12 and not 0
to 11 we are supposed to increment the value of <CODE>$month</CODE>. Among other interesting facts about <CODE>locatime()</CODE> we also see
an explanation of
<CODE>$year</CODE>, which as I've mentioned before is set to the number of years since 1900.

<P>
We have found the bug in our code and learned new things about
<CODE>localtime().</CODE> To correct the above code we just increment the
month after we call <CODE>localtime():</CODE>

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    my ($day,$month,$year) = (localtime)[3..5];
    $month++;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Using_print_and_Data_Dumper_f">Using print() and Data::Dumper for Debugging</A></H2></CENTER>
<P>
Sometimes you need to peek into complex data structures, and trying to
print them out can be tricky. That's where <CODE>Data::Dumper</CODE> comes to our rescue. For example if we create this complex data structure:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  $data =
    {
     array =&gt; [qw(a b c d)],
     hash  =&gt; {
               foo =&gt; &quot;oof&quot;,
               bar =&gt; &quot;rab&quot;,
              },
    };</pre>
        </td>
	    
      </tr>
    </table>
    <P>
How do we print it out? Very easily:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use Data::Dumper;
  print Dumper \$data;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
What we get is a pretty-printed <CODE>$data</CODE>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  $VAR1 = \{
            'hash' =&gt; {
                        'foo' =&gt; 'oof',
                        'bar' =&gt; 'rab'
                      },
            'array' =&gt; [
                        'a',
                        'b',
                        'c',
                        'd'
                       ]
          };</pre>
        </td>
	    
      </tr>
    </table>
    <P>
While writing this example I made a mistake and wrote <CODE>qw(a b c d)</CODE>
instead of <CODE>[qw(a b c d)]</CODE>. When I pretty-printed the contents of
<CODE>$data</CODE> I immediately saw my mistake:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  $VAR1 = \{
            'b' =&gt; 'c',
            'd' =&gt; 'hash',
            'HASH(0x80cd79c)' =&gt; undef,
            'array' =&gt; 'a'
          };</pre>
        </td>
	    
      </tr>
    </table>
    <P>
That's not what I wanted of course, but I spotted the bug and corrected it,
as you saw in the original example from above.

<P>
Of course you can use 

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  print STDERR $variable;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
or:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  warn $variable; </pre>
        </td>
	    
      </tr>
    </table>
    <P>
instead of print to have all the debug messages in the error_log, which
makes it even easier to debug your code.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="The_Importance_of_a_Good_Concise">The Importance of a Good Concise Coding Style</A></H2></CENTER>
<P>
Don't strive for elegant, clever code. Try to develop a good coding style
by writing code which is concise yet easy to understand. It's much easier
to find bugs in concise, simple code. And such code tends to have less
bugs.

<P>
The <EM>'one week ago'</EM> example from the previous section is not concise. There is a lot of
redundancy in it, and as a result it is harder to debug than it needs to
be. Here is a condensed version of the main loop. As you can see, this
version won't make it easier to understand the code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  for (0..6) {
    next if --$day;
    $year--,$month=12 unless --$month;
    $day = $month != 1 
        ? $month_len[$month-1] 
        : (($year % 4 or $year % 100 == 0) and $year % 400 )
             ? 28
             : 29;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Don't do that at home :) 

<P>
Why did I present this version? Because it is too obscure, which makes it
difficult to understand and maintain. On the other hand a part of this code
is easier to understand.

<P>
Larry Wall, the author of Perl, is a linguist. He tried to define the
syntax of Perl in a way that makes working in Perl much like working in
English. So it can be a good idea to learn Perl coding idioms, some of
which might seem odd at first but once you get used to them, you will find
it difficult to understand how you could have lived without them before.
I'll show just a few of the most common Perl coding idioms.

<P>
It's a good idea to write code which is more readable but which avoids
redundancy, so it's better to write:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  unless ($i) {...}</pre>
        </td>
	    
      </tr>
    </table>
    <P>
rather than:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  if ($i == 0) {...}</pre>
        </td>
	    
      </tr>
    </table>
    <P>
if you want to test for trueness only.

<P>
Use a much more concise, Perlish style:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  for my $j (0..6) {...}</pre>
        </td>
	    
      </tr>
    </table>
    <P>
instead of the syntax used in some other languages:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  for (my $j=0; $j&lt;=6; $j++) {...}</pre>
        </td>
	    
      </tr>
    </table>
    <P>
It's much simpler to write and comprehend code like this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  print &quot;something&quot; if $debug;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
than this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  if($debug){
    print &quot;something&quot;;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
A good style that improves understanding, readability and reduces the
chances of having a bug is shown below in the form of yet another rewrite
of our <EM>`one week ago'</EM> code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  for (0..6) {
    $day--;
    next if $day;
  
    $month--;
    unless ($month){
      $year--;
      $month=12
    }
  
    if($month == 1){
      $day = (($year % 4 or $year % 100 == 0) and $year % 400 ) 
           ? 28 : 29;
    } else {
      $day = $month_len[$month-1];
    }
  } </pre>
        </td>
	    
      </tr>
    </table>
    <P>
which is a happy medium between the excessively verbose style of the first
version and very obscure second version.

<P>
And of course a two liner, which is much faster and easier to understand
is:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  sub date_a_week_ago{
    my ($day,$month,$year) = (localtime(time-604800))[3..5];
    return sprintf &quot;%02d/%02d/%04d&quot;,$month+1,$day,$year+1900;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Just take the current date in seconds since epoch as <CODE>time()</CODE>
returns, subtract a week in seconds (7*24*60*60 = 604800) and feed the
result to <CODE>localtime()</CODE> - voila we've got the date of one week
ago!

<P>
Why is the last version important, when the first one works just fine? Not
because of performance issues (although this last one is twice as fast as
the first), but because there are more ways to put a bug in the first
version than there are in the last one.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Introduction_to_the_Perl_Debugge">Introduction to the Perl Debugger</A></H2></CENTER>
<P>
As we saw earlier, it's <EM>almost</EM> always possible to debug code with the help of <CODE>print().</CODE>
However, it is impossible to anticipate all the possible directions which a
program might take, and difficult to know what code to suspect when trouble
occurs. In addition, inline debugging code tends to add bloat and degrade
the performance of an application, although most applications offer inline
debugging as a compile time option to avoid these hits. In any case, this
information tends to only be useful to the programmer who added the print
statements in the first place.

<P>
Sometimes you have to debug tens of thousands lines of Perl in an
application, and while you may be a very experienced Perl programmer who
can understand Perl code quite well by just looking at it, no mere mortal
can even begin to understand what will actually happen in such a large
application, until the code is running. So you just don't know where to
start adding your trusty <CODE>print()</CODE> statements to see what is
happening inside.

<P>
The most effective way to track down a bug is to run the program inside an
interactive debugger. The majority of programming languages have such a
tool available, allowing one to see what is happening inside an application
while it is running. The basic features of an interactive debugger allow
you to:

<UL>
<P><LI>
<P>
Stop at a certain point in the code, based on a routine name or source file
and line number

<P><LI>
<P>
Stop at a certain point in the code, based on conditions such as the value
of a given variable

<P><LI>
<P>
Perform an action without stopping, based on the criteria above

<P><LI>
<P>
View and modify the value of variables at any given point

<P><LI>
<P>
Provide context information such as stack traces and source windows

</UL>
<P>
It does take practice to learn the most effective ways of using an
interactive debugger, but the time and effort will be paid back many-fold
in the long run.

<P>
Most C and C++ programmers are familiar with the interactive GNU debugger (<CODE>gdb</CODE>).  <CODE>gdb</CODE> is a stand-alone program that requires your code to be compiled with
debugging symbols to be useful. While <CODE>gdb</CODE>
can be used to debug the Perl interpreter itself, it cannot be used to
debug your Perl scripts.

<P>
Not to worry, Perl provides its own interactive debugger, called
<CODE>perldb</CODE>. Giving control of your Perl program to the interactive debugger is simply
a matter of specifying the <A HREF="#item__d">-d</A> command line switch. When this switch is used, Perl inserts debugging hooks
into the program syntax tree, but it leaves the job of debugging to a Perl
module separate from the perl binary itself.

<P>
I will start by introducing a few of the basic concepts and commands of the
Perl interactive debugger. These warm-up examples all run from the command
line, independent of mod_perl, but are all still relevant when we do
finally go inside Apache.

<P>
It might be useful to keep the <EM>perldebug</EM> manpage handy for reference while reading this section, and for future
debugging sessions on your own.

<P>
The interactive debugger will attach to the current terminal and present
you with a prompt just before the first program statement is executed. For
example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d -le 'print &quot;mod_perl rules the world&quot;'
  
  Loading DB routines from perl5db.pl version 1.0402
  
  Emacs support available.
  
  Enter h or `h h' for help.
  
  main::(-e:1):   print &quot;mod_perl rules the world&quot;
    DB&lt;1&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The source line shown is the line which Perl is <EM>about</EM> to execute, the <CODE>next</CODE> command (or just <CODE>n</CODE>) will cause this line to be executed after which execution will stop again
just before the next line:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  main::(-e:1):   print &quot;mod_perl rules the world&quot;
    DB&lt;1&gt; n
  mod_perl rules the world
  Debugged program terminated.  Use q to quit or R to restart,
  use O inhibit_exit to avoid stopping after program termination,
  h q, h R or h O to get additional info.
  DB&lt;1&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
In this case, our example code is only one line long, so we have finished
interacting after the first line of code is executed. Let's try again with
slightly longer example which is the following script:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  my $word = 'mod_perl';
  my @array = qw(rules the world);
  
  print &quot;$word @array\n&quot;;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Save the script in a file called <EM>domination.pl</EM> and run with the
<A HREF="#item__d">-d</A> switch:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d domination.pl
  
  main::(domination.pl:1):      my $word = 'mod_perl';
    DB&lt;1&gt; n
  main::(domination.pl:2):      my @array = qw(rules the world);
    DB&lt;1&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
At this point, the first line of code has been executed and the variable <CODE>$word</CODE> has been assigned the value <EM>mod_perl</EM>. We can check this by using the <CODE>p</CODE> command (an abbreviation for the <CODE>print</CODE>
command, the two are interchangeable):

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  main::(domination.pl:2):      my @array = qw(rules the world);
    DB&lt;1&gt; p $word
  mod_perl</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The <CODE>print</CODE> command works just like the Perl's built-in <CODE>print()</CODE> function,
but adds a trailing newline and outputs to the <CODE>$DB::OUT</CODE>
file handle, which is normally opened on the terminal where Perl was
launched from. Let's carry on:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;2&gt; n
  main::(domination.pl:4):      print &quot;$word @array\n&quot;;
    DB&lt;2&gt; p @array
  rulestheworld
    DB&lt;3&gt; n
  mod_perl rules the world
  Debugged program terminated.  Use q to quit or R to restart,
  use O inhibit_exit to avoid stopping after program termination,
  h q, h R or h O to get additional info.  </pre>
        </td>
	    
      </tr>
    </table>
    <P>
Ouch, <CODE>p @array</CODE> printed <CODE>rulestheworld</CODE> and not <CODE>rules the world</CODE>, as you might expect it to, but that's absolutely correct. If you print an
array without expanding it first into a string it will be printed without
adding the content of the <CODE>$&quot;</CODE> variable (otherwise known as
<CODE>$LIST_SEPARATOR</CODE> if the <CODE>English</CODE> pragma is being used) between the elements of the array.

<P>
If you type:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  print &quot;@array&quot;;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
the output will be <CODE>rules the world</CODE> since the default value of the
<CODE>$&quot;</CODE> variable is a single space.

<P>
You should have noticed by now that there is some valuable information to
the left of each executable statement:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  main::(domination.pl:4):      print &quot;$word @array\n&quot;;
    DB&lt;2&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
First is the current package name, in this case <CODE>main::</CODE>. Next is the current filename and statement line number, <EM>domination.pl</EM> and 4 in the example above. The number presented at the prompt is the
command number which can be used to recall commands from the session
history, using the <CODE>!</CODE> command followed by this number. For example,
<CODE>!1</CODE> would repeat the first command:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d -e0
  
  main::(-e:1):   0
    DB&lt;1&gt; p $]
  5.00503
    DB&lt;2&gt; !1
  p $]5.00503
    DB&lt;3&gt; </pre>
        </td>
	    
      </tr>
    </table>
    <P>
Where <CODE>$]</CODE> is the perl's version number. As you see <CODE>!1</CODE> prints the value of <CODE>$]</CODE>, prepended by the command that was executed.

<P>
Things start to get more interesting as the code does. In the example
script below (save it to a file called <EM>test.pl</EM>) we've increased the number of source files and packages by including the
standard
<CODE>Symbol</CODE> module, along with an invocation of its <CODE>gensym()</CODE> function:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use Symbol ();
  
  my $sym = Symbol::gensym();
  
  print &quot;$sym\n&quot;;</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d test.pl 
  
  main::(test.pl:3):      my $sym = Symbol::gensym();
    DB&lt;1&gt; n
  main::(test.pl:5):      print &quot;$sym\n&quot;;
    DB&lt;1&gt; n
  GLOB(0x80c7a44)</pre>
        </td>
	    
      </tr>
    </table>
    <P>
First, notice the debugger did not stop at the first line of the file. This
is because <CODE>use ...</CODE> is a compile-time statement, not a run-time statement. Also notice there
was more work going on than the debugger revealed. That's because the <CODE>next</CODE> command does not enter subroutine calls. To step into a subroutine code use
the <CODE>step</CODE>
command (or its abbreviated form <A HREF="#item_s">s</A>):

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d test.pl
  
  main::(test.pl:3):      my $sym = Symbol::gensym();
    DB&lt;1&gt; s
  Symbol::gensym(/usr/lib/perl5/5.00503/Symbol.pm:86):
  86:         my $name = &quot;GEN&quot; . $genseq++;
    DB&lt;1&gt; </pre>
        </td>
	    
      </tr>
    </table>
    <P>
Notice the source line information has changed to the
<CODE>Symbol::gensym</CODE> package and the <CODE>Symbol.pm</CODE> file. We can carry on by hitting the return key at each prompt, which
causes the debugger to repeat the last <CODE>step</CODE> or <CODE>next</CODE> command. It won't repeat a
<CODE>print</CODE> command though. The debugger will eventually return from the subroutine
back to our main program:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;1&gt; 
  Symbol::gensym(/usr/lib/perl5/5.00503/Symbol.pm:87):
  87:         my $ref = \*{$genpkg . $name};
    DB&lt;1&gt; 
  Symbol::gensym(/usr/lib/perl5/5.00503/Symbol.pm:88):
  88:         delete $$genpkg{$name};
    DB&lt;1&gt; 
  Symbol::gensym(/usr/lib/perl5/5.00503/Symbol.pm:89):
  89:         $ref;
    DB&lt;1&gt; 
  main::(test.pl:5):      print &quot;$sym\n&quot;;
    DB&lt;1&gt; 
  GLOB(0x80c7a44)</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Our line-by-line debugging approach has served us well for this small
program, but imagine the time it would take to step through a large
application at the same pace. There are several ways to speed up a
debugging session, one of which is known as <EM>setting a breakpoint</EM>. The <CODE>breakpoint</CODE> command (<CODE>b</CODE>) can be used for instructing the debugger to stop at a named subroutine or
at any line of any file. In this example session, at the first debugger
prompt we will set a breakpoint at the <CODE>Symbol::gensym</CODE> subroutine, telling the debugger to stop at the first line of this routine
when it is called. Rather than move along with <CODE>next</CODE> or <CODE>step</CODE> we give the <CODE>continue</CODE>
command (<A HREF="#item_c">c</A>) which tells the debugger to execute the script without stopping until it
reaches a breakpoint:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d test.pl
  
  main::(test.pl:3):      my $sym = Symbol::gensym();
    DB&lt;1&gt; b Symbol::gensym
    DB&lt;2&gt; c
  Symbol::gensym(/usr/lib/perl5/5.00503/Symbol.pm:86):
  86:         my $name = &quot;GEN&quot; . $genseq++;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now let's pretend we are debugging a large application where
<CODE>Symbol::gensym</CODE> might be called in various places. When the subroutine breakpoint is
reached, by default the debugger does not reveal where it was called from.
One way to find out this information is with the <CODE>Trace</CODE> command (<CODE>T</CODE>):

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;2&gt; T
  $ = Symbol::gensym() called from file `test.pl' line 3</pre>
        </td>
	    
      </tr>
    </table>
    <P>
In this example, the call stack is only one level deep, so only that line
is printed. We'll look at an example with a deeper stack later. The
left-most character reveals the context in which the subroutine was called.  <CODE>$</CODE> represents scalar context, in other examples you may see <CODE>@</CODE> which represents list context or <CODE>.</CODE> which represents void context. In our case we have called:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  my $sym = Symbol::gensym();</pre>
        </td>
	    
      </tr>
    </table>
    <P>
which calls the <CODE>Symbol::gensym()</CODE> in scalar context.

<P>
Below we've made our <EM>test.pl</EM> example a little more complex. First, we've added a <CODE>My::World</CODE> package declaration at the top of the script, so we are no longer working
in the <CODE>main::</CODE> package. Next, we've added a subroutine named <CODE>do_work()</CODE> which
invokes the familiar
<CODE>Symbol::gensym</CODE>, along with another function called
<CODE>Symbol::qualify</CODE> and then returns a hash reference of the results. The
<CODE>do_work()</CODE> routine is invoked inside a <EM>for</EM> loop which will be run twice:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  package My::World;
  
  use Symbol ();
  
  for (1,2) {
    do_work(&quot;now&quot;);
  }
  
  sub do_work {
    my($var) = @_;
  
    return undef unless $var;
  
    my $sym  = Symbol::gensym();
    my $qvar = Symbol::qualify($var);
  
    my $retval = {
                 'sym' =&gt; $sym,
                 'var' =&gt; $qvar,
                 };
  
    return $retval;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We'll start by setting a few breakpoints and then we use the <CODE>List</CODE>
command (<CODE>L</CODE>) to display them:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d test.pl
  
  My::World::(test.pl:5):   for (1,2) {
    DB&lt;1&gt; b Symbol::qualify
    DB&lt;2&gt; b Symbol::gensym
    DB&lt;3&gt; L
  /usr/lib/perl5/5.00503/Symbol.pm:
   86:        my $name = &quot;GEN&quot; . $genseq++;
     break if (1)
   95:        my ($name) = @_;
     break if (1)</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The filename and line number of the breakpoint are displayed just before
the source line itself. Because both breakpoints are located in the same
file, the filename is displayed only once. After the source line we see the
condition on which to stop. In this case, as the constant value 1
indicates, we will always stop at these breakpoints. Later on you'll see
how to specify a condition.

<P>
As we will see, when the <CODE>continue</CODE> command is executed, the execution of the program stops at one of these
breakpoints, either on line 86 or 95 of the <CODE>/usr/lib/perl5/5.00503/Symbol.pm</CODE> file, whichever is reached first. The displayed code lines are the first
rows of the two subroutines from <CODE>Symbol.pm</CODE>. Breakpoints may only be applied to lines of run-time executable code, you
cannot put breakpoints on empty lines or comments for example.

<P>
In our example the <CODE>List</CODE> command shows which lines the breakpoints were set on, but we cannot tell
which breakpoint belongs to which subroutine. There are two ways to find
this out. One is to run the
<CODE>continue</CODE> command and when it stops, execute the <CODE>Trace</CODE> command we saw before:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;3&gt; c
  Symbol::gensym(/usr/lib/perl5/5.00503/Symbol.pm:86):
  86:         my $name = &quot;GEN&quot; . $genseq++;
    DB&lt;3&gt; T
  $ = Symbol::gensym() called from file `test.pl' line 14
  . = My::World::do_work('now') called from file `test.pl' line 6</pre>
        </td>
	    
      </tr>
    </table>
    <P>
So we see that it was <CODE>Symbol::gensym</CODE>. The other way is to ask for a listing of a range of lines from the code.
For example, let's check which subroutine line 86 is a part of. We use the <CODE>list</CODE>
(lowercase!) command (<CODE>l</CODE>), which displays parts of the code. The
<CODE>list</CODE> command accepts various arguments, the one that we want to use here is a
range of lines. Since the breakpoint is at line 86, let's print a few lines
above and below that line:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;3&gt; l 85-87
  85      sub gensym () {
  86==&gt;b      my $name = &quot;GEN&quot; . $genseq++;
  87:         my $ref = \*{$genpkg . $name};</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now we know it's the <CODE>gensym</CODE> sub and we also see the breakpoint displayed with the help of the <CODE>==&gt;b</CODE> markup. We could also use the name of the sub to display its code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;4&gt; l Symbol::gensym
  85      sub gensym () {
  86==&gt;b      my $name = &quot;GEN&quot; . $genseq++;
  87:         my $ref = \*{$genpkg . $name};
  88:         delete $$genpkg{$name};
  89:         $ref;
  90      }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The <CODE>delete</CODE> command (<A HREF="#item_d">d</A>) is used to remove a breakpoint by specifying the line number of the
breakpoint. Let's remove the first one:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;5&gt; d 95</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The <CODE>Delete</CODE> command (with a capital `D') or <CODE>D</CODE> removes all currently installed breakpoints.

<P>
Now let's look again at the trace produced at the breakpoint:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;3&gt; c
  Symbol::gensym(/usr/lib/perl5/5.00503/Symbol.pm:86):
  86:         my $name = &quot;GEN&quot; . $genseq++;
    DB&lt;3&gt; T
  $ = Symbol::gensym() called from file `test.pl' line 14
  . = My::World::do_work('now') called from file `test.pl' line 6</pre>
        </td>
	    
      </tr>
    </table>
    <P>
As you can see, the stack trace prints the values which are passed into the
subroutine. Ah, and perhaps we've found our first bug, as we can see
<CODE>do_work()</CODE> was called in void context, so the return value was
lost into thin air. Let's change the <EM>'for'</EM> loop to check the return value of <CODE>do_work():</CODE>

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  for (1,2) {
    my $stuff = do_work(&quot;now&quot;);
    if ($stuff) {
        print &quot;work is done\n&quot;;
    }
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
In this session we will set a breakpoint at line 7 of <CODE>test.pl</CODE> where we check the return value of <CODE>do_work():</CODE>

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d test.pl
  
  My::World::(test.pl:5):   for (1,2) {
    DB&lt;1&gt; b 7
    DB&lt;2&gt; c
  My::World::(test.pl:7):     if ($stuff) {
    DB&lt;2&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Our program is still small, but already it is getting more difficult to
understand the context of just one line of code. The <CODE>window</CODE>
command (<CODE>w</CODE>) will list a few lines of code that surround the current line:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;2&gt; w
  4         
  5:        for (1,2) {
  6:          my $stuff = do_work(&quot;now&quot;);
  7==&gt;b       if ($stuff) {
  8:              print &quot;work is done\n&quot;;
  9           }
  10        }
  11        
  12        sub do_work {
  13:         my($var) = @_;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The arrow points to the line which is about to be executed and also
contains a <CODE>'b'</CODE> indicating that we have set a breakpoint at this line. The breakable lines
of code include a <CODE>`:'</CODE> immediately after the line number.

<P>
Now, let's take a look at the value of the <CODE>$stuff</CODE> variable with the trusty old <CODE>print</CODE> command:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;2&gt; p $stuff
  HASH(0x82b89b4)</pre>
        </td>
	    
      </tr>
    </table>
    <P>
That's not very useful information. Remember, the <CODE>print</CODE> command works just like the built-in <CODE>print()</CODE> function does.
The debugger's
<CODE>x</CODE> command evaluates a given expression and prints the results in a ``pretty''
fashion:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;3&gt; x $stuff
  0  HASH(0x82b89b4)
     'sym' =&gt; GLOB(0x826a944)
        -&gt; *Symbol::GEN0
     'var' =&gt; 'My::World::now'</pre>
        </td>
	    
      </tr>
    </table>
    <P>
There, things seem to be okay, let's double check by calling
<CODE>do_work()</CODE> with a different value and print the results:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;4&gt; x do_work('later')
  0  HASH(0x82bacc8)
     'sym' =&gt; GLOB(0x818f16c)
        -&gt; *Symbol::GEN1
     'var' =&gt; 'My::World::later'</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We can see the symbol was incremented from <CODE>GEN0</CODE> to <CODE>GEN1</CODE> and the variable later was qualified, as expected.

<P>
Now let's change the test program a little to iterate over a list of
arguments held in <CODE>@args</CODE> and print a slightly different message:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  package My::World;
  
  use Symbol ();
  
  my @args = qw(now later);
  for my $arg (@args) {
    my $stuff = do_work($arg);
    if ($stuff) {
        print &quot;do your work $arg\n&quot;;
    }
  }
  
  sub do_work {
    my($var) = @_;
  
    return undef unless $var;
  
    my $sym = Symbol::gensym();
    my $qvar = Symbol::qualify($var);
  
    my $retval = {
        'sym' =&gt; $sym,
        'var' =&gt; $qvar,
    };
  
    return $retval;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
There are only two arguments in the list, so stopping to look at each one
isn't too time consuming, but consider the debugging pace if we had a large
list of 100 or so entries. It is possible to customize breakpoints by
specifying a condition. Each time a breakpoint is reached, the condition is
evaluated, stopping only if the condition is true. In the session below,
the <CODE>window</CODE> command shows breakable lines and we set a breakpoint at line 7 with the
condition <CODE>$arg eq
'later'</CODE>. As we continue, the breakpoint is skipped when <CODE>$arg</CODE> has the value of <EM>now</EM> but not when it has the value of <EM>later</EM>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d test.pl
  
  My::World::(test.pl:5): my @args = qw(now later);
    DB&lt;1&gt; w
  2 
  3:      use Symbol ();
  4 
  5==&gt;    my @args = qw(now later);
  6:      for my $arg (@args) {
  7:          my $stuff = do_work($arg);
  8:          if ($stuff) {
  9:              print &quot;do your work $arg\n&quot;;
  10          }
  11      }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The <CODE>==&gt;</CODE> symbol shows us the line of code that's about to be executed.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;1&gt; b 7 $arg eq 'later'
    DB&lt;2&gt; c
  do your work now
  My::World::(test.pl:7):     my $stuff = do_work($arg);
    DB&lt;2&gt; n
  My::World::(test.pl:8):     if ($stuff) {
    DB&lt;2&gt; x $stuff
  0  HASH(0x82b90e4)
     'sym' =&gt; GLOB(0x82b9138)
        -&gt; *Symbol::GEN1
     'var' =&gt; 'My::World::later'
    DB&lt;5&gt; c
  do your work later
  Debugged program terminated.  Use q to quit or R to restart,</pre>
        </td>
	    
      </tr>
    </table>
    <P>
There are plenty more tricks left to pull from the perldb bag, but you
should now understand enough about the debugger to try them on your own
with the perldebug manpage by your side. Quick online help from inside the
debugger can be reached by typing the <A HREF="#item_h">h</A> command. It will display a list of the most useful commands and a short
explanation of what they do.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Interactive_Perl_Debugging_under">Interactive Perl Debugging under mod_cgi</A></H2></CENTER>
<P>
<CODE>Devel::ptkdb</CODE> is a visual Perl debugger that uses perlTk for the user interface and
requires a windows system like X-Windows or Windows to run.

<P>
To debug a plain perl script with ptkdb, invoke it as:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % perl -d:ptkdb myscript.pl</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The Tk application will be loaded. Now you can do most of the debugging you
did with the command line Perl debugger, but using a simple GUI to
set/remove breakpoints, browse the code, step through it and more.

<P>
With the help of ptkdb you can debug your CGI scripts running under
mod_cgi. Be sure that the web server's Perl installation includes the Tk
package. In order to enable the debugger you should change your ``shebang''
line from

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #! /usr/local/bin/perl -Tw</pre>
        </td>
	    
      </tr>
    </table>
    <P>
to

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #! /usr/local/bin/perl -Twd:ptkdb</pre>
        </td>
	    
      </tr>
    </table>
    <P>
You can debug scripts remotely if you're using a Unix based server and if
the machine where you are writing the script has an X-server. The X-server
can be another Unix workstation, or a Macintosh or Win32 platform with an
appropriate X-Windows package. You must insert the following <CODE>BEGIN</CODE> subroutine into your script:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  BEGIN {
    $ENV{'DISPLAY'} = &quot;myHostname:0.0&quot; ;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
You can use either the IP (<EM>123.123.123.123:0.0</EM>) or the DNS convention (<EM>myhost.com:0.0</EM>). You must be sure that your web server has permission to open windows on
your X-server (see the <EM>xhost</EM>
manpage for more info).

<P>
Access the web page with the browser and <EM>Submit</EM> the script as normal. The ptkdb window should appear on the monitor if you
have correctly set the <CODE>$ENV{'DISPLAY'}</CODE> variable. At this point you can start debugging your script. Be aware that
the browser may timeout waiting for the script to run.

<P>
To expedite debugging you may want to set your breakpoints in advance with
a <EM>.ptkdbrc</EM> file and use the <CODE>$DB::no_stop_at_start</CODE> variable. NOTE: for debugging web scripts you may have to have the <EM>.ptkdbrc</EM>
file installed in the server account's home directory (~www) or whatever
username the webserver is running under. Also try installing a <EM>.ptkdbrc</EM> file in the same directory as the target script.

<P>
META: insert snapshots of ptkdb screen

<P>
ptkdb is not part of the standard perl distribution; it is available from
CPAN: <A
HREF="http://www.perl.com/CPAN/authors/id/A/AE/AEPAGE/">http://www.perl.com/CPAN/authors/id/A/AE/AEPAGE/</A>
 

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Non_Interactive_Perl_Debugging_u">Non-Interactive Perl Debugging under mod_perl</A></H2></CENTER>
<P>
To debug scripts running under mod_perl either use <A HREF="././debug.html#Interactive_mod_perl_Debugging">Apache::DB (interactive Perl debugging)</A> or an older non-interactive method as described below.

<P>
The <CODE>NonStop</CODE> debugger option enables you to get some decent debugging information when
running under mod_perl. For example, before starting the server:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % setenv PERL5OPT -d
  % setenv PERLDB_OPTS &quot;NonStop=1 LineInfo=db.out AutoTrace=1 frame=2&quot;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now watch db.out for line:filename info. This is most useful for tracking
those core dumps that normally leave us guessing, even with a stack trace
from gdb.  <EM>db.out</EM> will show you what Perl code triggered the core dump.  <EM>'man perldebug'</EM> for more <CODE>PERLDB_OPTS</CODE>. Note that Perl will ignore <CODE>PERL5OPT</CODE> if <CODE>PerlTaintCheck</CODE> is <CODE>On</CODE>.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Interactive_mod_perl_Debugging">Interactive mod_perl Debugging</A></H2></CENTER>
<P>
Now we'll turn to looking at how the interactive debugger is used in a
mod_perl environment. The <CODE>Apache::DB</CODE> module available from CPAN provides a wrapper around <CODE>perldb</CODE> for debugging Perl code running under mod_perl.

<P>
The server must be run in non-forking mode to use the interactive debugger,
this mode is turned on by passing the <CODE>-X</CODE> flag to the httpd executable. It is convenient to use an <CODE>IfDefine</CODE> section around the <CODE>Apache::DB</CODE> configuration, the example below does this using the name <EM>PERLDB</EM>. With this setup, debugging is only turned on when starting the server
with the <CODE>httpd -D PERLDB</CODE> command.

<P>
This section should be at the top of the Perl configuration section of the
configuration file, before any other Perl code is pulled in, so that
debugging symbols will be inserted into the syntax tree, triggered by the
call to <CODE>Apache::DB-&gt;init</CODE>. The <CODE>Apache::DB::handler</CODE> can be configured using any of the <CODE>Perl*Handler</CODE> directives, in this case you use a <CODE>PerlFixupHandler</CODE> so handlers in the response phase will bring up the debugger prompt:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  &lt;IfDefine PERLDB&gt;
  
    &lt;Perl&gt;
      use Apache::DB ();
      Apache::DB-&gt;init;
    &lt;/Perl&gt;
  
    &lt;Location /&gt;
      PerlFixupHandler Apache::DB
    &lt;/Location&gt;
  
  &lt;/IfDefine&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Since we have used <CODE>/</CODE> as the argument to the <CODE>Location</CODE> directive, the debugger will be invoked for any kind of request (even for
static documents and images) but of course it will immediately quit unless
there is some Perl module registered to handle these requests.

<P>
In our first example, we will debug the standard <CODE>Apache::Status</CODE>
module, which is configured like this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlModule Apache::Status
  &lt;Location /perl-status&gt;
    PerlHandler Apache::Status
    SetHandler perl-script
  &lt;/Location&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
When the server is started with the debugging flag, a notice will be
printed to the console:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % httpd -X -D PERLDB
  [notice] Apache::DB initialized in child 950</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The debugger prompt will not be available until the first request is made,
in our case to <A
HREF="http://localhost/perl-status.">http://localhost/perl-status.</A> Once
we are at the prompt, all the standard debugging commands are available.
First we run window to get some of the context for the code being debugged,
then we move to the next statement after a value has been assigned to
<CODE>$r</CODE>, and finally we print the request URI. If no breakpoints are set, the <CODE>continue</CODE> command will give control back to Apache and the request will finish with
the <CODE>Apache::Status</CODE> main menu showing in the browser window:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  Loading DB routines from perl5db.pl version 1.0402
  Emacs support available.
  
  Enter h or `h h' for help.
  
  Apache::Status::handler(/usr/lib/perl5/site_perl/5.005/i386-linux/Apache/Status.pm:55): 
  55:         my($r) = @_;
    DB&lt;1&gt; w
  52      }
  53
  54      sub handler {
  55==&gt;       my($r) = @_;
  56:         Apache-&gt;request($r); #for Apache::CGI
  57:         my $qs = $r-&gt;args || &quot;&quot;;
  58:         my $sub = &quot;status_$qs&quot;;
  59:         no strict 'refs';
  60
  61:         if($qs =~ s/^(noh_\w+).*/$1/) {
    DB&lt;1&gt; n
 Apache::Status::handler(/usr/lib/perl5/site_perl/5.005/i386-linux/Apache/Status.pm:56):
  56:         Apache-&gt;request($r); #  for Apache::CGI
    DB&lt;1&gt; p $r-&gt;uri
  /perl-status
    DB&lt;2&gt; c</pre>
        </td>
	    
      </tr>
    </table>
    <P>
All the techniques we saw while debugging plain perl scripts can be applied
to this debugging session.

<P>
Debugging <CODE>Apache::Registry</CODE> scripts is somewhat different, because the handler routine does quite a bit
of work before it reaches your script. In this example, we make a request
for <CODE>/perl/test.pl</CODE>, which consists of this code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use strict;
  
  my $r = shift;
  $r-&gt;send_http_header('text/plain');
  
  print &quot;mod_perl rules&quot;;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
When a request is issued, the debugger stops at line 28 of
<EM>Apache/Registry.pm</EM>. We set a breakpoint at line 140, which is the line that actually calls
the script wrapper subroutine. The
<CODE>continue</CODE> command will bring us to that line, where we can step into the script
handler:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  Apache::Registry::handler(/usr/lib/perl5/site_perl/5.005/i386-linux/Apache/Registry.pm:28):
28:         my $r = shift;
    DB&lt;1&gt; b 140
    DB&lt;2&gt; c
  Apache::Registry::handler(/usr/lib/perl5/site_perl/5.005/i386-linux/Apache/Registry.pm:140):
  140:            eval { &amp;{$cv}($r, @_) } if $r-&gt;seqno;
    DB&lt;2&gt; s
  Apache::ROOT::perl::test_2epl::handler((eval 87):3):
  3:        my $r = shift;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Notice the funny package name, that's generated from the URI of the request
for namespace protection. The filename is not displayed, since the code was
compiled via <CODE>eval(),</CODE> but the <CODE>print</CODE> command can be used to show you <CODE>$r-&gt;filename</CODE>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;2&gt; n
  Apache::ROOT::perl::test_2epl::handler((eval 87):4):
  4:        $r-&gt;send_http_header('text/plain');
    DB&lt;2&gt; p $r-&gt;filename
  /home/httpd/perl/test.pl</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The line number might seem off too, but the window command will give you a
better idea where you are:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DB&lt;4&gt; w
  1:      package Apache::ROOT::perl::test_2epl;use Apache qw(exit);
  sub handler {  use strict;
  2 
  3:        my $r = shift;
  4==&gt;      $r-&gt;send_http_header('text/plain');
  5 
  6:        print &quot;mod_perl rules&quot;;
  7 
  8       }
  9       ;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The code from the <EM>test.pl</EM> file is between lines 2 and 7, the rest is the <CODE>Apache::Registry</CODE> magic to cache your code inside a
<EM>handler</EM> subroutine.

<P>
It will always take some practice and patience when putting together
debugging strategies that make effective use of the interactive debugger
for various situations. Once you have a good strategy, bug squashing can
actually be quite a bit of fun!

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="ptkdb_and_Interactive_mod_perl_D">ptkdb and Interactive mod_perl Debugging</A></H2></CENTER>
<P>
As you saw earlier you can use the <CODE>ptkdb</CODE> visual debugger to debug CGI scripts running under mod_cgi. But it won't
work for mod_perl using the same configuration as used in mod_cgi. We have
to tweak the <EM>Apache/DB.pm</EM> module to use <EM>Devel/ptkdb.pm</EM> instead of
<EM>Apache/perl5db.pl</EM>.

<P>
Open the file in your favorite editor and replace:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    require 'Apache/perl5db.pl';</pre>
        </td>
	    
      </tr>
    </table>
    <P>
with:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    require 'Devel/ptkdb.pm';</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now when you use the interactive mod_perl debugger configuration from the
previous section and issue a request, the <EM>ptkdb</EM> visual debugger will be loaded.

<P>
If you are debugging <CODE>Apache::Registry</CODE> scripts, as in the terminal debugging mode example, go to line 140 (or to
whatever line the <CODE>eval
{ &amp;{$cv}($r, @_) } if $r-</CODE>seqno;&gt; statement is located) and press the &lt;step in&gt; button to
start the debug of the script itself.

<P>
Note that you can use Apache with <CODE>ptkdb</CODE> in plain multi-server mode, you don't have to start <CODE>httpd</CODE> with the <CODE>-X</CODE> option.

<P>
META: One caveat:

<P>
When the request is completed, <CODE>ptkdb</CODE> hangs. Does anyone know what code should be registered for it to exit on
completion? To replace the original <CODE>Apache::DB</CODE> cleanup code, as:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    if (ref $r) {
        $SIG{INT} = \&amp;DB::catch;
        $r-&gt;register_cleanup(sub { 
            $SIG{INT} = \&amp;DB::ApacheSIGINT();
        });
    }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Any Perl/Tk guru to assist???

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Debugging_when_Server_Crashes_on">Debugging when Server Crashes on Startup before Writing to Log File.</A></H2></CENTER>
<P>
If your server crashes on startup, you need to start it under gdb and ask
it to generate a stack trace.

<P>
I'll emulate a faulty server by starting a startup file with the
<CODE>dump()</CODE> command:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  startup.pl
  ----------
  dump;
  1;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
and then requiring this file from the <EM>httpd.conf</EM>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlRequire /path/to/startup.pl</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Make sure no server is running on port 80 or use an alternate config with
an alternate port if using a production server.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % gdb /path/to/httpd
  (gdb) set args -X</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Use:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  set args -X -f /path/to/alternate/serverconfig_ifneeded.conf</pre>
        </td>
	    
      </tr>
    </table>
    <P>
if the server must be started from an alternative configuration file.

<P>
Now run the program:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  (gdb) run
  
  Starting program: /usr/local/apache/bin/httpd -X
  
  Program received signal SIGABRT, Aborted.
  0x400da4e1 in __kill () from /lib/libc.so.6</pre>
        </td>
	    
      </tr>
    </table>
    <P>
At this point the server should die because of the call to <CODE>dump()</CODE>. When that happens we use <CODE>bt</CODE> or <CODE>where</CODE> to ask for a stack back trace.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  (gdb) where
  
  #0  0x400da4e1 in __kill () from /lib/libc.so.6
  #1  0x80d43bc in Perl_my_unexec ()
  #2  0x8119544 in Perl_pp_goto ()
  #3  0x8118990 in Perl_pp_dump ()
  #4  0x812b2ad in Perl_runops_standard ()
  #5  0x80d3a9c in perl_eval_sv ()
  #6  0x807ef1c in perl_do_file ()
  #7  0x807ef4f in perl_load_startup_script ()
  #8  0x807b7ec in perl_cmd_require ()
  #9  0x8092af7 in ap_clear_module_list ()
  #10 0x8092f43 in ap_handle_command ()
  #11 0x8092fd7 in ap_srm_command_loop ()
  #12 0x80933e0 in ap_process_resource_config ()
  #13 0x8093ca2 in ap_read_config ()
  #14 0x809db63 in main ()
  #15 0x400d41eb in __libc_start_main (main=0x809d8dc &lt;main&gt;, argc=2, 
      argv=0xbffffab4, init=0x80606f8 &lt;_init&gt;, fini=0x812b38c &lt;_fini&gt;, 
      rtld_fini=0x4000a610 &lt;_dl_fini&gt;, stack_end=0xbffffaac)
      at ../sysdeps/generic/libc-start.c:90</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If you do not know what this trace means, you could send it to the mod_perl
mailing list to ask for help. Make sure to include the version numbers of
Apache, mod_perl and Perl, and use a subject line that says something about
the problem rather than 'help'.

<P>
In our case we already know that the server is supposed to die when
compiling the startup file and we can clearly see that from the trace. We
always read it from the bottom upward:

<P>
We are in config file:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #13 0x8093ca2 in ap_read_config ()</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We do require:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #8  0x807b7ec in perl_cmd_require ()</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We load the file and compile it:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #6  0x807ef1c in perl_do_file ()
  #5  0x80d3a9c in perl_eval_sv ()</pre>
        </td>
	    
      </tr>
    </table>
    <P>
<CODE>dump()</CODE> gets executed:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #3  0x8118990 in Perl_pp_dump ()</pre>
        </td>
	    
      </tr>
    </table>
    <P>
<CODE>dump()</CODE> calls <CODE>__kill()</CODE>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  #0  0x400da4e1 in __kill () from /lib/libc.so.6</pre>
        </td>
	    
      </tr>
    </table>
    <P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Hanging_Processes_Detection_and">Hanging Processes: Detection and Diagnostics</A></H1></CENTER>
<P>
Sometimes a httpd process might hang in the middle of processing a request,
either because there is a bug in your code (e.g. the code is stuck in a
while loop), it gets blocked by some system call or because of a resource
deadlock) or for some other reason. In order to fix the problem we need to
learn what circumstances the process hangs in (detection), so we can
reproduce the problem and after that to discover why there is problem
(diagnostics).

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Hanging_because_of_the_OS_Proble">Hanging because of the OS Problem</A></H2></CENTER>
<P>
Sometimes you can find a process hanging because of some kind of the system
problem. For example if the processes was doing some disk IO operation it
might get stuck in uninterruptible sleep (<CODE>'D'</CODE> disk wait in <CODE>ps(1)</CODE> report, <CODE>'U'</CODE> in <CODE>top(1))</CODE> which indicates that either something is broken in
your kernel or that you're using NFS. Or and you cannot kill&nbsp;-9 this process.

<P>
Another process that cannot be killed with kill&nbsp;-9 is a zombie process (<CODE>'Z'</CODE> disk wait in <CODE>ps(1)</CODE> report, <CODE>&lt;defunc&gt;</CODE> in <CODE>top(1)),</CODE> in which case the process is already dead and
Apache didn't wait on it properly.

<P>
In the case of <EM>disk wait</EM> you can actually get the <EM>wait</EM> channel from <CODE>ps(1)</CODE> and look it up in your kernel symbol table
to find out what resource it was waiting on. It might point the way to what
component of the system was misbehaving if the problem occurred frequently.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="An_Example_of_Code_that_Might_Ha">An Example of Code that Might Hang a Process</A></H2></CENTER>
<P>
Deadlock is the situation where, for example, two processes, say X and Y,
need two resources, A and B to continue. X holds onto A and Y holds onto B.
There is no possibility for Y to continue before X releases A. But X cannot
release A before it gets Y.

<P>
Look at the following example. Your process has to gain a lock on some
resource (e.g. a file) before it continues. So it makes an attempt, and if
that fails it <CODE>sleep()s</CODE> for a second and increments a counter:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  until(gain_lock()){
    $tries++;
    sleep 1;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Because there are many processes competing for this resource, or perhaps
because there is a deadlock, <CODE>gain_lock()</CODE> always fails. The
process is hung.

<P>
Another situation that you may very often encounter is exclusive lock
starvation. Generally there are two lock types in use: <EM>SHARED</EM>
locks, which allow many processes to perform <EM>READ</EM> operations simultaneously, and <EM>EXCLUSIVE</EM> locks. The latter permits access only by a single process and so makes a
safe <EM>WRITE</EM> operation possible.

<P>
You can lock any kind of resource, although in our examples we will talk
about files.

<P>
If there is a <EM>READ</EM> lock request, it is granted as soon as the file becomes unlocked or
immediately if it is already <EM>READ</EM> locked. The lock status becomes <EM>READ</EM> on success.

<P>
If there is a <EM>WRITE</EM> lock request, it is granted as soon as the file becomes unlocked. Lock
status becomes <EM>WRITE</EM> on success.

<P>
Normally it is the <EM>WRITE</EM> lock request which is the most important. If the file is being <EM>READ</EM> locked, a process that requests to write will poll until there are no
reading or writing process left. However, lots of processes can
successfully read the file, since they do not block each other from doing
so. This means that a process that wants to write to the file (first
obtaining an exclusive lock) never gets a chance to squeeze in. The
following diagram represents a possible scenario where everybody can read
but no one can write:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  [-p1-]                 [--p1--]
     [--p2--]
   [---------p3---------]
                 [------p4-----]
     [--p5--]   [----p5----]</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Let's look at some real code and see it in action. The following script
imports <CODE>flock()</CODE> related parameters from the <CODE>Fcntl</CODE> module, and opens a file that will be locked. It then defines and sets two
variables: <CODE>$lock_type</CODE> and <CODE>$lock_type_verbose</CODE>. These are set to
<CODE>LOCK_EX</CODE> and <CODE>EX</CODE> respectively if the first command line argument (<CODE>$ARGV[0]) is defined and equal to &lt;EM&gt;w&lt;/EM&gt;.  This indicates that this
process will try to gain a &lt;EM&gt;WRITE&lt;/EM&gt; (exclusive) lock.  Otherwise the
two are set to &lt;CODE&gt;LOCK_SH&lt;/CODE&gt; and &lt;SH</CODE> for a <EM>SHARED</EM> (read) lock.

<P>
Once the variables are set, we enter the infinite <CODE>while(1)</CODE> loop that attempts to lock the file by the mode set in <CODE>$lock_type</CODE>. It report success and the type of lock that was gained, then it sleeps
for a random period between 0 and 9 seconds and unlocks the file. The loop
then starts from the beginning.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  lock.pl
  -------------------
  #!/usr/bin/perl -w
  use Fcntl qw(:flock);
  
  $lock = &quot;/tmp/lock&quot;;
  
  open LOCK, &quot;&gt;$lock&quot; or die &quot;Cannot open $lock for writing: $!&quot;;
  my $lock_type         = LOCK_SH;
  my $lock_type_verbose = 'SH';
  if (defined $ARGV[0] and $ARGV[0] eq 'w'){
    $lock_type         = LOCK_EX;
    $lock_type_verbose = 'EX';
  }
  
  while(1){
    flock LOCK,$lock_type;
      # start of critical section
    print &quot;$$: $lock_type_verbose\n&quot;;
    sleep int(rand(10));
      # end of critical section
    flock LOCK, LOCK_UN;
  }
  close LOCK;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
It's very easy to see <EM>WRITE</EM> process starvation if you spawn a few of the above scripts simultaneously.
Start the first few as <EM>READ</EM>
processes and then start one <EM>WRITE</EM> process like this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre> % ./lock.pl r &amp; ; ./lock.pl r &amp; ; ./lock.pl r &amp; ; ./lock.pl w &amp;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
You see something like:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  24233: SH
  24232: SH
  24232: SH
  24233: SH
  24232: SH
  24233: SH
  24231: SH
  24231: SH
  24231: SH</pre>
        </td>
	    
      </tr>
    </table>
    <P>
and not a single <CODE>EX</CODE> line... When you kill off the reading processes, then the write process
will gain its lock. Note that as this is a rough example, I used the
<CODE>sleep()</CODE> function. To simulate a real situation you need to use
the <CODE>Time::HiRes</CODE> module, which allows you to choose more precise intervals to sleep.

<P>
The interval between lock and unlock is called a <EM>Critical Section</EM>, which should be kept as short as possible (in terms of the time taken to
execute the code, and not in terms of the number of lines of code). As you
just saw, a single sleep statement can make the critical section long.

<P>
To summarize, if you have a script that uses both <EM>READ</EM> and <EM>WRITE</EM>
locks and the critical section isn't very short, the writing process might
be starved. After a while a browser that initiated this request will
timeout the connection and abort the request, but it's much more likely
that user will press the <EM>Stop</EM> or <EM>Reload</EM> button before that happens. Since the process in question is just waiting,
there is no way for Apache to know that the request was aborted. It will
hang until the lock is gained. Only when a write to a client's broken
connection is attempted will Apache terminate the script.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Detecting_hanging_processes">Detecting hanging processes</A></H2></CENTER>
<P>
It's not so easy to detect hanging processes. There is no way you can tell
how long the request is taking to process by using plain system utilities
like <CODE>ps()</CODE> and <CODE>top().</CODE> The reason is that each
Apache process serves many requests without quitting. System utilities can
tell how long the process has been running since its creation, but this
information is useless in our case, since Apache processes normally run for
extended periods.

<P>
However there are a few approaches that can help to detect a hanging
process.

<P>
If the process hangs and demands lots of resources it's quite easy to spot
it by using the <CODE>top()</CODE> utility. You will see the same process
show up in the first few lines of the automatically refreshed report. But
often the hanging process uses few resources, e.g. when waiting for some
event to happen.

<P>
Another easy case is when some process thrashes the <EM>error_log</EM>, writing millions of error messages there. Generally this process uses
lots of resources and is also easily spotted by using <CODE>top().</CODE>

<P>
There are other tools that report the status of Apache processes.

<UL>
<P><LI><STRONG><A NAME="item_The">The mod_status module, which is usually accessed from the
/server_status location.</A></STRONG>
<P><LI><STRONG><A NAME="item_The">The Apache::VMonitor module.</A></STRONG>
</UL>
<P>
Both tools provide counters of processed requests per Apache process.

<P>
You can watch the report for a few minutes, and try to spot any process
which has the same number of processed requests while its status is 'W'
(waiting). This means that it has hung.

<P>
But if you have fifty processes, it can be quite hard to spot such a
process.  <A HREF="././modules.html#Apache_Watchdog_RunAway_Hang">Apache::Watchdog::RunAway is a hanging processes monitor and terminator</A> that implements this feature and should be used to solve this kind of
problem.

<P>
If you've got a real problem, and the processes hang one after the other,
the time will come when the number of hanging processes is equal to the
value of <CODE>MaxClients</CODE>. This means that no more processes will be spawned. As far as the users
are concerned your server is down. It is easy to detect this situation,
attempt to resolve it and notify the administrator using a simple crontab
watchdog that requests some very light script periodically. (See
<A HREF="././control.html#Monitoring_the_Server_A_watchdo">Monitoring the Server. A watchdog.</A>)

<P>
In the watchdog you set a timeout appropriate for your service, which may
be anything from a few seconds to a few minutes. If the server fails to
respond before the timeout expires, the watchdog has spotted trouble and
attempts to restart the server. After a restart an email report is sent to
the administrator saying that there was a problem and whether or not the
restart was successful.

<P>
If you get such reports constantly something is wrong with your web service
and you should revise your code. Note that it's possible that your server
is being overloaded by more requests than it can handle, so the requests
are being queued and not processed for a while, which triggers the
watchdog's alarm. If this is a case you may need to add more servers or
more memory, or perhaps split your single machine across a cluster of
machines.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Determination_of_the_reason">Determination of the reason</A></H2></CENTER>
<P>
Given the process id (PID), there are three ways to find out where the
server is hanging.

<OL>
<P><LI>
<P>
Deploying the Perl calls tracing mechanism. This will allow to spot the
location of the Perl code that has triggered the problem.

<P><LI>
<P>
Using the system calls tracing utilities, like <CODE>strace(1)</CODE> or
<CODE>truss(1).</CODE> This approach reveals low level details about a
potential misbehavior of some part of the system.

<P><LI>
<P>
Using an interactive debugger, like <CODE>gdb(1).</CODE> When the process
is stuck, and you don't know what it was doing just before it has got
stuck, with gdb you can attach to this process and print its calls stack,
to reveal where the last call was made from. Just like with strace or truss
you see the system call trace and not the Perl calls.

</OL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="Using_the_Perl_Trace">Using the Perl Trace</A></H3></CENTER>
<P>
To see where an httpd is ``spinning'', try adding this to your script or a
startup file:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use Carp ();
  $SIG{'USR2'} = sub { 
     Carp::confess(&quot;caught SIGUSR2!&quot;);
  };</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The above code asigns a signal handler for the <CODE>USR2</CODE> signal. This signal has been chosen because it's least likely to be used by
the other parts of the server.

<P>
We check the registered signal handlers with help of
<A HREF="././debug.html#Apache_Status_Embedded_Inter">Apache::Status</A>. What we see at <A
HREF="http://localhost/perl-status?sig">http://localhost/perl-status?sig</A>
is :

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  USR2 = \&amp;MyStartUp::__ANON__</pre>
        </td>
	    
      </tr>
    </table>
    <P>
<CODE>MyStartUp</CODE> is the name of the package I've used in mine
<EM>startup.pl</EM>.

<P>
After applying this server configuration, let's use this simple code
example, where <CODE>sleep(10000)</CODE> will emulate a hanging process:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  debug/perl_trace.pl
  -------------------
  $|=1;
  print &quot;Content-type:text/plain\r\n\r\n&quot;;
  print &quot;[$$] Going to sleep\n&quot;;
  hanging_sub();
  sub hanging_sub {sleep 10000;}</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We execute the above script as
<EM>http://localhost/perl/debug/perl_trace.pl</EM>, we have used <CODE>$|=1;</CODE>
and printed the PID with <CODE>$$</CODE> to learn what process ID we want to work with.

<P>
No we issue the command line, using the PID we have just saw being printed
to the browser's window:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % kill -USR2 PID</pre>
        </td>
	    
      </tr>
    </table>
    <P>
And watch this showing up at the <EM>error_log</EM> file:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  caught SIGUSR2!
      at /home/httpd/perl/startup/startup.pl line 32
  MyStartUp::__ANON__('USR2') called 
      at /home/httpd/perl/debug/perl_trace.pl line 5
  Apache::ROOT::perl::debug::perl_trace_2epl::hanging_sub() called 
      at /home/httpd/perl/debug/perl_trace.pl line 4
  Apache::ROOT::perl::debug::perl_trace_2epl::handler('Apache=SCALAR(0x8309d08)') 
    called 
      at /usr/lib/perl5/site_perl/5.005/i386-linux/Apache/Registry.pm 
        line 140
  eval {...} called 
      at /usr/lib/perl5/site_perl/5.005/i386-linux/Apache/Registry.pm
        line 140
  Apache::Registry::handler('Apache=SCALAR(0x8309d08)') called 
      at PerlHandler subroutine `Apache::Registry::handler' line 0
  eval {...} called 
      at PerlHandler subroutine `Apache::Registry::handler' line 0</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We can clearly see that the process ``hangs'' in the code executed at line
5 of the <EM>/home/httpd/perl/debug/perl_trace.pl</EM> script, and it was called by the <CODE>hanging_sub()</CODE> routine defined
at line 4.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="Using_the_System_Calls_Trace">Using the System Calls Trace</A></H3></CENTER>
<P>
Depending on the operating system you should have one of the
<CODE>truss(1)</CODE> or <CODE>strace(1)</CODE> utilities available. In the following examples we will use <CODE>strace(1)</CODE>.

<P>
There are two ways to get the trace of the process with
<CODE>strace(1)</CODE> (similar to <CODE>gdb(1)).</CODE> The first one is
to tell <CODE>strace(1)</CODE> to start the process and do the tracing on
it:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % strace perl -le 'print &quot;mod_perl rules&quot;'</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The second is tell <CODE>strace(1)</CODE> to attach to the process that's
already running. You need to know the PID of the process.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % strace -p PID</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Replace PID with the process number you want to check on.

<P>
There are many more useful arguments accepted by <CODE>strace(1)</CODE>
that you might find useful. For example you can tell it to trace only
specific system calls:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % strace -e trace=open,write,close,nanosleep \
      perl -le 'print &quot;mod_perl rules&quot;'</pre>
        </td>
	    
      </tr>
    </table>
    <P>
In this example we have asked <CODE>strace(1)</CODE> to show us only the <EM>open</EM>,
<EM>write</EM>, <EM>close</EM>, <EM>nanosleep</EM> which simplifies the observing of the output generated by
<CODE>strace(1)</CODE> if you know what you are looking for.

<P>
Let's write a mod_perl script that hangs, and deploy <CODE>strace(1)</CODE> to find the point it hangs at:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  hangme.pl
  ---------
  $|=1;
  my $r = shift;
  $r-&gt;send_http_header('text/plain');
  
  print &quot;PID = $$\n&quot;;
  
  while(1){
    $i++;
    sleep 1;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The reason this simple code hangs is obvious. It never breaks from the
while loop. As you have noticed, it prints the PID of the current process
to the browser. Of course in a real situation you cannot use the same
trick. In the previous section I have presented a few ways to detect the
runaway processes and their PIDs.

<P>
I save the above code in a file and execute it from the browser. Note that
I've made STDOUT unbuffered with <CODE>$|=1;</CODE> so I will immediately see the process ID. Once the script is requested, the
script prints the process PID and obviously hangs. So we press the <CODE>'Stop'</CODE>
button, but the process continues to hang in this code. Isn't apache
supposed to detect the broken connection and abort the request?
<EM>Yes</EM> and <EM>No</EM>, you will understand soon what's really happening.

<P>
First let's attach to the process and see what it's doing. I use the PID
the script printed to the browser, which is 10045 in this case:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % strace -p 10045
  
  [...truncated identical output...]
  SYS_175(0, 0xbffff41c, 0xbffff39c, 0x8, 0) = 0
  SYS_174(0x11, 0, 0xbffff1a0, 0x8, 0x11) = 0
  SYS_175(0x2, 0xbffff39c, 0, 0x8, 0x2)   = 0
  nanosleep(0xbffff308, 0xbffff308, 0x401a61b4, 0xbffff308, 0xbffff41c) = 0
  time([940973834])                       = 940973834
  time([940973834])                       = 940973834
  [...truncated the identical output...]</pre>
        </td>
	    
      </tr>
    </table>
    <P>
It isn't what we expected to see, is it? These are some system calls we
don't see in our little example. What we actually see is how Perl
translates our code into system calls. Since we know that our code hangs in
this snippet:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  while(1){
    $i++;
    sleep 1;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We <EM>"easily"</EM> figure out that the first three system calls implement the <CODE>$i++</CODE>, while the other other three are responsible for the
<CODE>sleep 1</CODE> call.

<P>
Generally the situation is the reverse of our example. You detect the
hanging process, you attach to it and watch the trace of calls it does (or
the last few commands if the process is hanging waiting for something, e.g.
when blocking on a file lock request). From watching the trace you figure
out what it's actually doing, and probably find the corresponding lines in
your Perl code. For example let's see how one process <EM>"hangs"</EM> while requesting an exclusive lock on a file exclusively locked by another
process:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  excl_lock.pl
  ---------
  use Fcntl qw(:flock);
  use Symbol;
  
  if ( fork() ) {
    my $fh = gensym;
    open $fh, &quot;&gt;/tmp/lock&quot; or die &quot;cannot open /tmp/lock $!&quot;;
    print &quot;$$: I'm going to obtain the lock\n&quot;;
    flock $fh, LOCK_EX;
    print &quot;$$: I've got the lock\n&quot;;
    sleep 20;
    close $fh;
  
  } else {
    my $fh = gensym;
    open $fh, &quot;&gt;/tmp/lock&quot; or die &quot;cannot open /tmp/lock $!&quot;;
    print &quot;$$: I'm going to obtain the lock\n&quot;;
    flock $fh, LOCK_EX;
    print &quot;$$: I've got the lock\n&quot;;
    sleep 20;
    close $fh;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The code is simple. The process executing the code forks a second process,
and both do the same thing: generate a unique symbol to be used as a file
handler, open the lock file for writing using the generated symbol, lock
the file in exclusive mode, sleep for 20 seconds (pretending to do some
lengthy operation) and close the lock file, which also unlocks the file.

<P>
The <CODE>gensym</CODE> function is imported from the <CODE>Symbol</CODE> module. The
<CODE>Fcntl</CODE> module provides us with a symbolic constant <CODE>LOCK_EX</CODE>. This is imported via the <CODE>:flock</CODE> tag, which imports this and other <CODE>flock()</CODE> constants.

<P>
The code used by both processes is identical, therefore we cannot predict
which one will get its hands on the lock file and succeed in locking it
first, so we add <CODE>print()</CODE> statements to find the PID of the
process blocking (waiting to get the lock) on a lock request.

<P>
When the above code executed from the command line, we see that one of the
processes gets the lock:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % ./excl_lock.pl
  
  3038: I'm going to obtain the lock
  3038: I've got the lock
  3037: I'm going to obtain the lock</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Here we see that process 3037 is blocking, so we attach to it:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % strace -p 3037
  
  about to attach c10
  flock(3, LOCK_EX</pre>
        </td>
	    
      </tr>
    </table>
    <P>
It's clear from the above trace, that the process waits for an exclusive
lock. (Note, that the missing closing parentnheses is not a typo!)

<P>
As you become familiar with watching the traces of different processes, you
will understand what is happening more easily.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H3><A NAME="Using_the_Interactive_Debugger">Using the Interactive Debugger</A></H3></CENTER>
<P>
Another approach to see a trace of the running code is to use a debugger
such as <CODE>gdb</CODE> (the GNU debugger). It's supposed to work on any platform which supports
the GNU development tools. Its purpose is to allow you to see what is going
on <EM>inside</EM> a program while it executes, or what it was doing at the moment it crashed.  

<P>
To trace the execution of a process, <CODE>gdb</CODE> needs to know the process id (PID) and the path to the binary that the
process is executing. For Perl code it's <EM>/usr/bin/perl</EM> (or whatever is the path to your Perl), for httpd processes it will be the
path to your httpd executable.

<P>
Here are a few examples using gdb.

<P>
Let's go back to our last locking example, execute it as before and attach
to the process that didn't get the lock:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % gdb /usr/bin/perl 3037</pre>
        </td>
	    
      </tr>
    </table>
    <P>
After starting the debugger we execute the <CODE>where</CODE> command to see the trace:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  (gdb) where
  #0  0x40131781 in __flock ()
  #1  0x80a5421 in Perl_pp_flock ()
  #2  0x80b148d in Perl_runops_standard ()
  #3  0x80592b8 in perl_run ()
  #4  0x805782f in main ()
  #5  0x400a6cb3 in __libc_start_main (main=0x80577c0 &lt;main&gt;, argc=2, 
      argv=0xbffff7f4, init=0x8056af4 &lt;_init&gt;, fini=0x80b14fc &lt;_fini&gt;, 
      rtld_fini=0x4000a350 &lt;_dl_fini&gt;, stack_end=0xbffff7ec)
      at ../sysdeps/generic/libc-start.c:78</pre>
        </td>
	    
      </tr>
    </table>
    <P>
That's not what we expected to see and now it's a different trace.
<CODE>#0</CODE> tells us the most recent call that was executed, which is a C language
<CODE>flock()</CODE> implementation. But the previous call (<CODE>#1</CODE>) isn't <CODE>print(),</CODE> as we would expect, but a higher level of
Perl's internal <CODE>flock().</CODE> If we follow the trace of calls what
we actually see is an Opcodes tree, which can be better presented as:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  __libc_start_main
    main ()
      perl_run () 
        Perl_runops_standard ()
          Perl_pp_flock ()
            __flock ()</pre>
        </td>
	    
      </tr>
    </table>
    <P>
So I would say that it's less useful than <CODE>strace</CODE>, since if there are several <CODE>flock()s</CODE> it's almost impossible
to know which of them was called. This problem is solved by <CODE>strace</CODE>, which shows the sequence of the system calls executed. Using this
sequence we can locate the corresponding lines in the code.

<P>
(META: the above is wrong - you can ask to display the previous command
executed by the program (not gdb)! What is it?)

<P>
When you attach to a running process with debugger, the program stops
executing and control of the program is passed to the debugger. You can
continue the normal program run with the <CODE>continue</CODE> command or execute it step by step with the <CODE>next</CODE> and <CODE>step</CODE> commands which you type at the <CODE>gdb</CODE> prompt. (<CODE>next</CODE> steps over any function calls in the line, while <CODE>step</CODE> steps into them).

<P>
C/C++ debuggers are a very large topic and beyond the scope of this
document, but the gdb man page is quite good and you can try <CODE>info
gdb</CODE> as well. You might also want to check the <CODE>ddd</CODE> (Data Display Debbuger) which provides a visual interface to <CODE>gdb</CODE> and other debuggers. It even knows how to debug Perl programs!

<P>
For completeness, let's see the gdb trace of the httpd process that's still
hanging in the <CODE>while(1)</CODE> loop of the first example in this section:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % gdb /usr/local/apache/bin/httpd 1005
  
  (gdb) where
  #0  0x4014a861 in __libc_nanosleep ()
  #1  0x4014a7ed in __sleep (seconds=1) at ../sysdeps/unix/sysv/linux/sleep.c:78
  #2  0x8122c01 in Perl_pp_sleep ()
  #3  0x812b25d in Perl_runops_standard ()
  #4  0x80d3721 in perl_call_sv ()
  #5  0x807a46b in perl_call_handler ()
  #6  0x8079e35 in perl_run_stacked_handlers ()
  #7  0x8078d6d in perl_handler ()
  #8  0x8091e43 in ap_invoke_handler ()
  #9  0x80a5109 in ap_some_auth_required ()
  #10 0x80a516c in ap_process_request ()
  #11 0x809cb2e in ap_child_terminate ()
  #12 0x809cd6c in ap_child_terminate ()
  #13 0x809ce19 in ap_child_terminate ()
  #14 0x809d446 in ap_child_terminate ()
  #15 0x809dbc3 in main ()
  #16 0x400d3cb3 in __libc_start_main (main=0x809d88c &lt;main&gt;, argc=1, 
      argv=0xbffff7e4, init=0x80606f8 &lt;_init&gt;, fini=0x812b33c &lt;_fini&gt;, 
      rtld_fini=0x4000a350 &lt;_dl_fini&gt;, stack_end=0xbffff7dc)
      at ../sysdeps/generic/libc-start.c:78</pre>
        </td>
	    
      </tr>
    </table>
    <P>
As before we can see a complete trace of the last executed call.

<P>
As you have noticed, I still haven't explained why the process hanging in
the <CODE>while(1)</CODE> loop isn't aborted by Apache. The next section covers this.

<P>
META: add the note about using the 'curinfo' gdb macro to perform an easy
detecting of the hanging location.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Debugging_Hanging_processes_con">Debugging Hanging processes (continued)</A></H1></CENTER>
<P>
META: incomplete

<P>
mod_perl comes with a number of useful of gdb macros to ease the debug
process. You will find the file with macros in the mod_perl source
distribution in the <EM>.gdbinit</EM> file (mod_perl-x.xx/.gdbinit). You might want to modify the macro
definitions.

<P>
In order to use this you need to compile mod_perl with
<CODE>PERL_DEBUG=1</CODE>.

<P>
To debug the server, start it:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % httpd -X</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Issue a request to the offending script that hangs. Find the PID number of
the process that hangs.

<P>
Go to the server root:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % cd /usr/local/apache</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now attach to it with gdb (replace the <CODE>PID</CODE> with the actual process id) and load the macros from <EM>.gdbinit</EM>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % gdb /path/to/httpd PID
  % source /usr/src/mod_perl-x.xx/.gdbinit</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now you can start the server (<EM>httpd</EM> below is a gdb macro):

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  (gdb) httpd</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now run the <CODE>curinfo</CODE> macro:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  (gdb) curinfo</pre>
        </td>
	    
      </tr>
    </table>
    <P>
It should tell you the line/filename of the offending Perl code.

<P>
Add this to <EM>.gdbinit</EM>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  define longmess
    set $sv = perl_eval_pv(&quot;Carp::longmess()&quot;, 1)
    printf &quot;%s\n&quot;, ((XPV*) ($sv)-&gt;sv_any )-&gt;xpv_pv
  end</pre>
        </td>
	    
      </tr>
    </table>
    <P>
and when you reload the macros, run:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  (gdb) longmess</pre>
        </td>
	    
      </tr>
    </table>
    <P>
to produce a Perl stacktrace.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H2><A NAME="Debugging_core_Dumping_Code">Debugging core Dumping Code</A></H2></CENTER>
<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>       $ perl -e dump
        Abort(coredump)</pre>
        </td>
	    
      </tr>
    </table>
    <P>
META: should I move the <CODE>Apache::StatINC</CODE> here? (I think not, since it relates to other topics like reloading config
files, but you should mention it here with a pointer to it)

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="PERL_DEBUG_1_Build_Option">PERL_DEBUG=1 Build Option</A></H1></CENTER>
<P>
Building mod_perl with <CODE>PERL_DEBUG=1</CODE>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  perl Makefile.PL PERL_DEBUG=1</pre>
        </td>
	    
      </tr>
    </table>
    <P>
will:

<OL>
<P><LI>
<P>
Add `-g' to EXTRA_CFLAGS

<P><LI>
<P>
Turn on PERL_TRACE

<P><LI>
<P>
Set PERL_DESTRUCT_LEVEL=2

<P><LI>
<P>
Link against <CODE>libperld</CODE> if -e $Config{archlibexp}/CORE/libperld$Config{lib_ext}

</OL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Apache_Debug">Apache::Debug</A></H1></CENTER>
<P>
(META: to be written)

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use Apache::Debug ();
  Apache::Debug::dump($r, SERVER_ERROR, &quot;Uh Oh!&quot;);</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This module sends what may be helpful debugging information to the client
rather than to <EM>error_log</EM>.

<P>
Also, you could try using a larger emergency pool, try this instead of
Apache::Debug:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre> $^M = 'a' x (1&lt;&lt;18);  #256k buffer
 use Carp ();
 $SIG{__DIE__} = \&amp;Carp::confess;
 eval { Carp::confess(&quot;init&quot;) };</pre>
        </td>
	    
      </tr>
    </table>
    <P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Debug_Tracing">Debug Tracing</A></H1></CENTER>
<P>
To enable mod_perl debug tracing, configure mod_perl with the PERL_TRACE
option:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre> perl Makefile.PL PERL_TRACE=1</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The trace levels can then be enabled via the <CODE>MOD_PERL_TRACE</CODE>
environment variable which can contain any combination of:

<DL>
<P><DT><STRONG><A NAME="item_c">c</A></STRONG><DD>
<P>
Trace directive handling during <EM>Apache</EM> (non-mod_perl)
<STRONG>c</STRONG>onfiguration directive handling. (Startup.)

<P><DT><STRONG><A NAME="item_d">d</A></STRONG><DD>
<P>
Trace directive handling during <EM>mod_perl</EM>  <STRONG>d</STRONG>irective processing during configuration read. (Startup.)

<P><DT><STRONG><A NAME="item_s">s</A></STRONG><DD>
<P>
Trace processing of <EM>&lt;Perl&gt;</EM>  <STRONG>s</STRONG>ections. (Startup.)

<P><DT><STRONG><A NAME="item_h">h</A></STRONG><DD>
<P>
Trace Perl <STRONG>h</STRONG>andler callbacks. (RunTime.)

<P><DT><STRONG><A NAME="item_g">g</A></STRONG><DD>
<P>
Trace <STRONG>g</STRONG>lobal variable handling, interpreter construction, <CODE>END</CODE>
blocks, etc. (RunTime.)

<P><DT><STRONG><A NAME="item_all">all</A></STRONG><DD>
<P>
<STRONG>all</STRONG> of the options listed above. (Startup + RunTime.)

</DL>
<P>
One way of setting this variable is by adding this directive to
<EM>httpd.conf</EM>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlSetEnv MOD_PERL_TRACE all</pre>
        </td>
	    
      </tr>
    </table>
    <P>
For example if you want to see a trace of the <CODE>PerlRequire</CODE> and
<CODE>PerlModule</CODE> directives as they are executed, use:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  PerlSetEnv MOD_PERL_TRACE d</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Of course you can use the command line environment setting:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  % setenv MOD_PERL_TRACE all
  % httpd -X</pre>
        </td>
	    
      </tr>
    </table>
    <P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="gdb_says_there_are_no_debugging_">gdb says there are no debugging symbols</A></H1></CENTER>
<P>
During <EM>make install</EM> Apache strips all the debugging symbols. To prevent this you should use <EM>--without-execstrip</EM>  <CODE>./configure</CODE>
option. So if you configure Apache via mod_perl, you should do:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  panic% perl Makefile.PL USE_APACI=1 \
    APACI_ARGS='--without-execstrip' [other options]</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Alternatively you can copy the unstripped binary manually. For example we
did:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  panic# cp apache_1.3.17/src/httpd /home/httpd/httpd_perl/bin/httpd_perl</pre>
        </td>
	    
      </tr>
    </table>
    <P>
As you know you need an unstripped executable to be able to debug it. While
you can compile mod_perl with <A HREF="#item__g">-g</A> (or <CODE>PERL_DEBUG=1</CODE>), the Apache <CODE>install</CODE> strips the symbols.

<P>
<EM>Makefile.tmpl</EM> contains a line:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  IFLAGS_PROGRAM  = -m 755 -s </pre>
        </td>
	    
      </tr>
    </table>
    <P>
Removing the -s does the trick (If you cannot find it in
<EM>Makefile.tmpl</EM> do it directly in <EM>Makefile</EM>). Alternatively you rerun <CODE>make</CODE> and copy the unstripped httpd binary away.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Debugging_Signal_Handlers_SIG_">Debugging Signal Handlers ($SIG{FOO})</A></H1></CENTER>
<P>
The current Perl implementation does not restore the original Apache C
handler when you use the <CODE>local $SIG{FOO}</CODE> clause. While the save/restore of <CODE>$SIG{ALRM}</CODE> was fixed in mod_perl 1.19_01 (CVS version), other signals are not yet
fixed. The real fix should probably be in Perl itself.

<P>
Until recently <CODE>local $SIG{ALRM}</CODE> restored the <CODE>SIGALRM</CODE> handler to Perl's handler, not the handler it was in the first place
(Apache's
<CODE>alrm_handler()</CODE>). If you build mod_perl with <CODE>PERL_TRACE=1</CODE> and set the <CODE>MOD_PERL_TRACE</CODE> environment variable to <STRONG>g</STRONG>, you will see this in the <EM>error_log</EM> file:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  mod_perl: saving SIGALRM (14) handler 0x80b1ff0
  mod_perl: restoring SIGALRM (14) handler from: 0x0 to: 0x80b1ff0</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If nobody has touched <CODE>$SIG{ALRM}</CODE>, <CODE>0x0</CODE> will be the same address as the others.

<P>
If you work with signal handlers you should take a look at the
<CODE>Sys::Signal</CODE> module, which solves the problem:

<P>
<CODE>Sys::Signal</CODE> - Set signal handlers with restoration of the existing C sighandler. Get it
from <A HREF="././download.html#Perl">CPAN</A>.

<P>
The usage is simple. If the original code was:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  # If a timeout happens and C&lt;SIGALRM&gt; is thrown, the alarm() will be
  # reset, otherwise C&lt;alarm 0&gt; is reached and timer is reset as well.
  eval {
    local $SIG{ALRM} = sub { die &quot;timeout\n&quot; };
    alarm $timeout;
    ... db stuff ...
    alarm 0;
  };
  die $@ if $@;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now you would write:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use Sys::Signal ();
  eval {
    my $h = Sys::Signal-&gt;set(ALRM =&gt; sub { die &quot;timeout\n&quot; });
    alarm $timeout;
    ... do something that may timeout ...
    alarm 0;
  };
  die $@ if $@;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This should be fixed in Perl 5.6.1, so if you use this version of Perl,
chances are that you don't need to use <CODE>Sys::Signal</CODE>.

<P>
mod_perl tries to deal only with those signals that cause conflict with
Apache's. Currently this is only <CODE>SIGALRM</CODE>. If there is another one that gives you trouble, you can add it to the
list in
<EM>perl_config.c</EM> after <EM>"ALRM"</EM>, before <EM>NULL</EM>.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  static char *sigsave[] = { &quot;ALRM&quot;, NULL };</pre>
        </td>
	    
      </tr>
    </table>
    <P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Code_Profiling">Code Profiling</A></H1></CENTER>
<P>
(Meta: duplication??? I've started to write about profiling somewhere in
this file)

<P>
It is possible to profile code run under mod_perl with the
<CODE>Devel::DProf</CODE> module available on CPAN. However, you must have apache version 1.3b3 or
higher and the <CODE>PerlChildExitHandler</CODE>
enabled. When the server is started, <CODE>Devel::DProf</CODE> installs an
<CODE>END</CODE> block (to write the <CODE>tmon.out</CODE> file) which will be run when the server is shutdown. Here's how to start
and stop a server with the profiler enabled:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre> % setenv PERL5OPT -d:DProf
 % httpd -X -d `pwd` &amp;
 ... make some requests to the server here ...
 % kill `cat logs/httpd.pid`
 % unsetenv PERL5OPT
 % dprofpp</pre>
        </td>
	    
      </tr>
    </table>
    <P>
See also: <CODE>Apache::DProf</CODE>



<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Devel_Peek">Devel::Peek</A></H1></CENTER>
<P>
Devel::Peek - A data debugging tool for the XS programmer

<P>
Let's see an example of Perl allocating a buffer only once, regardless of
<CODE>my()</CODE> scoping, although it will <CODE>realloc()</CODE> if the
size is &gt;
<CODE>SvLEN</CODE>:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use Devel::Peek;
  
  for (1..3) {
      foo();
  }
  
  sub foo {
      my $sv;
      Dump $sv;
      $sv = 'x' x 100_000;
      $sv = &quot;&quot;;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The output:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  SV = NULL(0x0) at 0x8138008
    REFCNT = 1
    FLAGS = (PADBUSY,PADMY)
  SV = PV(0x80e5794) at 0x8138008
    REFCNT = 1
    FLAGS = (PADBUSY,PADMY)
    PV = 0x815f808 &quot;&quot;\0
    CUR = 0
    LEN = 100001
  SV = PV(0x80e5794) at 0x8138008
    REFCNT = 1
    FLAGS = (PADBUSY,PADMY)
    PV = 0x815f808 &quot;&quot;\0
    CUR = 0</pre>
        </td>
	    
      </tr>
    </table>
    <P>
We can see that on the second and subsequent calls <CODE>$sv</CODE> already has preallocated memory.

<P>
So, if you can afford the memory, a larger buffer means fewer <CODE>brk()</CODE>
syscalls. If you watch that example with <CODE>strace</CODE> you will only see calls to <CODE>brk()</CODE> the first time through the loop. So this is a case where your module might
want to pre-allocate the buffer like this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  package Your::Proxy;
  
  my $buffer = ' ' x 100_000;
  $buffer = &quot;&quot;;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Now only the parent has to <CODE>brk()</CODE> at server startup, each child
already will already have an allocated buffer. Just reset to ``'' when you
are done.

<P>
Note: Preallocating a scalar in this way saves reallocation in v5.005 but
may not do so in other versions.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="How_can_I_find_out_if_a_mod_perl">How can I find out if a mod_perl code has a memory leak</A></H1></CENTER>
<P>
The <CODE>Apache::Leak</CODE> module (derived from <CODE>Devel::Leak</CODE>) should help you detecting the leakages in your code. For example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  leaktest.pl
  -----------
  use Apache::Leak;
  
  my $global = &quot;FooAAA&quot;;
  
  leak_test {
    $$global = 1;
    ++$global;
  };</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The argument to <CODE>leak_test()</CODE> is an anonymous sub, so you can just throw it any code you suspect might be
leaking. Beware, it will run the code twice! The first time in, new <CODE>SV</CODE>s are created, but does not mean you are leaking. The second pass will give
better evidence. You do not need to be inside mod_perl to use it. From the
command line, the above script outputs:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  ENTER: 1482 SVs
  new c28b8 : new c2918 : 
  LEAVE: 1484 SVs
  ENTER: 1484 SVs
  new db690 : new db6a8 : 
  LEAVE: 1486 SVs
  !!! 2 SVs leaked !!!</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Build a debuggable Perl to see dumps of the <CODE>SV</CODE>s. The simple way to have both a normal Perl and debuggable Perl is to
follow hints in the
<CODE>SUPPORT</CODE> doc for building <CODE>libperld.a</CODE>. When that is built, copy the <CODE>perl</CODE> from that directory to your Perl bin directory, but name it <CODE>dperl</CODE>.

<P>
Our example's leak explanation: <CODE>$$global = 1;</CODE> : new global variable
<CODE>FooAAA</CODE> created with value of <CODE>1</CODE>, this will not be destroyed until this module is destroyed. Under mod_perl
the module doesn't get destroyed until the process quits.

<P>
<CODE>Apache::Leak</CODE> is not very user-friendly, have a look at
<CODE>B::LexInfo</CODE>. It is possible to see something that might appear to be a leak, but is
actually just a Perl optimization. e.g. consider this code:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  sub foo {
    my $string = shift;
  }</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  foo(&quot;a string&quot;);</pre>
        </td>
	    
      </tr>
    </table>
    <P>
<CODE>B::LexInfo</CODE> will show you that Perl does not release the value from $string, unless you
<CODE>undef()</CODE> it. This is because Perl anticipates the memory will
be needed for another string, the next time the subroutine is entered.
You'll see similar behaviour for <CODE>@array</CODE> length,
<CODE>%hash</CODE> keys, and scratch areas of the pad-list for OPs such as
<CODE>join()</CODE>, `<CODE>.</CODE>', etc.

<P>
<CODE>Apache::Status</CODE> includes a <CODE>StatusLexInfo</CODE> option which can show you the internals of your code.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Debugging_your_code_in_Single_Se">Debugging your code in Single Server Mode</A></H1></CENTER>
<P>
Running in httpd -X mode is good only for testing during the development
phase.

<P>
You want to test that your application correctly handles global variables
(if you have any - the less you have of them the better of course - but
sometimes you just can't do without them). It's hard to test with multiple
servers serving your cgi since each child has a different value for its
global variables. Imagine that you have a
<CODE>random()</CODE> sub that returns a random number and you have the following script.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use vars qw($num);
  $num ||= random();
  print ++$num;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This script initializes the variable <CODE>$num</CODE> with a random value, then increments it on each request and prints it out.
Running this script in a multiple server environments will result in
something like <CODE>1</CODE>,
<CODE>9</CODE>, <CODE>4</CODE>, <CODE>19</CODE> (a different number each time you hit the browser's reload button) since
each time your script will be served by a different child. (On some
operating systmes, e.g. AIX, the parent httpd process will assign all of
the requests to the same child process if all of the children are idle).
But if you run in <CODE>httpd
-X</CODE> single server mode you will get <CODE>2</CODE>, <CODE>3</CODE>, <CODE>4</CODE>, <CODE>5</CODE>... (assuming that <CODE>random()</CODE> returned <CODE>1</CODE> at the first call)

<P>
But do not get too obsessive with this mode, since working in single server
mode sometimes hides problems that show up when you switch to normal
(multi-server) mode.

<P>
Consider an application that allows you to change the configuration at run
time. Let's say the script produces a form to change the background color
of the page. It's not good design, but for the sake of demonstrating the
potential problem we will assume that our script doesn't write the changed
background color to the disk, but simply changes it in memory, like this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  use vars qw($bgcolor);
    # assign default value at first invocation
  $bgcolor ||= &quot;white&quot;;
    # modify the color if requested to
  $bgcolor = $q-&gt;param('bgcolor') || $bgcolor;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
So you have typed in a new color, and in response, your script prints back
the html with a new color - you think that's it! It was so simple. If you
keep running in single server mode you will never notice that you have a
problem...

<P>
If you run the same code in normal server mode, after you submit the color
change you will get the result as expected, but when you call the same URL
again (not reload!) the chances are that you will get back the original
default color (white in our case), since only the child which processed the
color change request knows about the global variable change. Just remember
that children can't share information, other than that which they inherited
from their parent on their birth. Of course you could use a hidden variable
for the color to be remembered, or store it on the server side (database,
shared memory, etc).

<P>
If you use the Netscape client while your server is running in
single-process mode, if the output returns HTML with <CODE>&lt;IMG&gt;</CODE>
tags, then the loading of the images will take a long time, since
Netscape's <CODE>KeepAlive</CODE> feature gets in the way. Netscape tries to open multiple connections and
keep them open. Because there is only one server process listening, each
connection has to time-out before the next succeeds. Turn off <CODE>KeepAlive</CODE> in <EM>httpd.conf</EM> to avoid this effect. Alternatively (assuming you use the image size
parameters, so that Netscape will be able to render the rest of the page)
you can press <STRONG>STOP</STRONG> after a few seconds.

<P>
In addition you should be aware that when running with <CODE>-X</CODE> you will not see the status messages that the parent server normally writes
to the error_log. (``server started'', ``server stopped'', etc.). Since <CODE>httpd
-X</CODE> causes the server to handle all requests itself, without forking any
children, there is no controlling parent to write the status messages.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Apache_DumpHeaders_Watch_HTTP">Apache::DumpHeaders - Watch HTTP Transaction Via Headers</A></H1></CENTER>
<P>
This module is used to watch an HTTP transaction, looking at client and
servers headers.

<P>
With <CODE>Apache::ProxyPassThru</CODE> configured, you are able to watch your browser talk to any server besides
the one with this module living inside.

<P>
<CODE>Apache::DumpHeaders</CODE> has the ability to filter on IP addresses, has an interface for other
modules to decide if the headers should be dumped or not and a function to
only dump <EM>n%</EM> of the transactions.

<P>
For more information read the module's manpage.

<P>
Download the module from <A HREF="././download.html#CPAN_Downloads">CPAN</A>.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<CENTER><H1><A NAME="Apache_DebugInfo_Log_Various_">Apache::DebugInfo - Log Various Bits Of Per-Request Data</A></H1></CENTER>
<P>
<CODE>Apache::DebugInfo</CODE> offers the ability to monitor various bits of per-request data. Its
functionality is similar to
<A HREF="././debug.html#Apache_DumpHeaders_Watch_HTTP">Apache::DumpHeaders</A>
while offering several additional features, including the ability to:

<DL>
<P><DT><STRONG><A NAME="item__">- separate inbound from outbound HTTP headers</A></STRONG><DD>
<P><DT><STRONG>- view the contents of $r-&gt;notes and $r-&gt;pnotes</STRONG><DD>
<P><DT><STRONG>- view any of these at the various points in the request cycle</STRONG><DD>
<P><DT><STRONG>- add output for any request phase from a single entry point</STRONG><DD>
<P><DT><STRONG>- use as a PerlInitHandler or with direct method calls</STRONG><DD>
<P><DT><STRONG>- use partial IP addresses for filtering by IP</STRONG><DD>
<P><DT><STRONG>- offer a subclassable interface</STRONG><DD>
</DL>
<P>
See the module's manpage for more details.

[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>


    <p>
    <div class="navbar">
      <a href="./multiuser.html">Prev</a>                                 |
      <A HREF="./index.html"         >Contents</A> |
      <A HREF="./index.html#search"  >Search</A>   |
      <A HREF="./index.html#download">Download</A> |
      <a href="./browserbugs.html">Next</a>
    </div>
    <p>

    <table width="60%" align="center">

      <tr>
	<td>
	  <div class="notice">
	  <B>Your corrections of the technical and grammatical
	     errors are very welcome. You are encouraged to help me
	     improve this guide.  If you have something to contribute
	     please <A HREF="help.html#Contacting_me"> send it
	     directly to me</A>.</B>
	  </div>
	</td>
      </tr>

      <tr>
	<td>
	  <div class="ad">
	    The <a href="http://www.modperl.com/">
	      <B>Writing Apache Modules with Perl and C</B></a>
	    book can be purchased online from <a
	      href="http://www.ora.com/catalog/wrapmod/">O'Reilly </a>
	    and <a
	    href="http://www.amazon.com/exec/obidos/ASIN/156592567X/writinapachemodu">
	      Amazon.com</a>.
	  </div>
	</td>
      </tr>

</table>

<center>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<table cellspacing=2 cellpadding=2>

<tr align=center valign=top>
<td align=center valign=center>

<b><font size=-1>Written by <a
href="help.html#Contacting_me">Stas Bekman</a>.<br> Last Modified at 02/19/2001
</font></b>
<br>

</td>

<td>

<a href="http://perl.apache.org"><img src="images/mod_perl2.jpg"  border=0 alt="mod_perl icon" border=0 height=59 width=150></a>
<br>

</td>

<td>

<font size=-2>Use of the Camel for Perl is <br>
a trademark of <a href="http://www.ora.com">O'Reilly &amp; Associates</a>,<br>
and is used by permission. </font> 
<br>

</td>

</tr>
</table>
</center>

</body>
</html>
