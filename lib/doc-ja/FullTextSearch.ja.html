<HTML>
<HEAD>
<TITLE>DBIx::FullTextSearch - MySQL をストレージとしてドキュメントのインデクスをつくる</TITLE>
<LINK REV="made" HREF="mailto:hackers@FreeBSD.org">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<UL>

		<LI><A HREF="#Frontends">Frontends</A>
		<LI><A HREF="#_">フロントエンド</A>
		<LI><A HREF="#Backends">Backends</A>
		<LI><A HREF="#_">バックエンド</A>
		<LI><A HREF="#Mixing_frontends_and_backends">Mixing frontends and backends</A>
		<LI><A HREF="#_">フロントエンドとバックエンドの融合</A>
	</UL>

	<LI><A HREF="#METHODS">METHODS</A>
	<LI><A HREF="#INDEX_OPTIONS">INDEX OPTIONS</A>
	<LI><A HREF="#ERROR_HANDLING">ERROR HANDLING</A>
	<LI><A HREF="#VERSION">VERSION</A>
	<LI><A HREF="#BUGS">BUGS</A>
	<LI><A HREF="#DEVELOPMENT">DEVELOPMENT</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
	<LI><A HREF="#CREDITS">CREDITS</A>
	<LI><A HREF="#COPYRIGHT">COPYRIGHT</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
	<LI><A HREF="#OTHER_PRODUCTS_and_why_I_ve_writ">OTHER PRODUCTS and why I've written this module</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
DBIx::FullTextSearch - MySQL
をストレージとしてドキュメントのインデクスをつくる

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE>    use DBIx::FullTextSearch;
    use DBI;
    # データベースに接続 (通常のDBI)
    my $dbh = DBI-&gt;connect('dbi:mysql:database', 'user', 'passwd');
</PRE>
<P>
<PRE>    # ストップリストの作成
    my $sl = DBIx::FullTextSearch::StopList-&gt;create_default($dbh, 'sl_en', 'English');
</PRE>
<P>
<PRE>    # デフォルトの english ストップリストと english ステマでインデクスを作成
    my $fts = DBIx::FullTextSearch-&gt;create($dbh, 'fts_web_1',
                frontend =&gt; 'string', backend =&gt; 'blob',
                stoplist =&gt; 'sl_en', stemmer =&gt; 'en-us');
    # あるいは既存のものを開く
    # my $fts = DBIx::FullTextSearch-&gt;open($dbh, 'fts_web_1');
</PRE>
<P>
<PRE>    # ドキュメントをインデクスする
    $fts-&gt;index_document('krtek', 'krtek leze pod zemi');
    $fts-&gt;index_document('jezek', 'Jezek ma ostre bodliny.');
</PRE>
<P>
<PRE>    # マッチの検索
    my @docs = $fts-&gt;contains('foo');
    my @docs = $fts-&gt;econtains('+foo', '-Bar');
    my @docs = $fts-&gt;search('+foo -Bar');
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
DBIx::FullTextSearch is a flexible solution for indexing contents of
documents. It uses the MySQL database to store the information about words
and documents and provides Perl interface for indexing new documents,
making changes and searching for matches. For DBIx::FullTextSearch, a
document is nearly anything -- Perl scalar, file, Web document, database
field.

<P>
DBIx::FullTextSearch はドキュメントの内容をインデクスするためのフレキ
シブルなソリューションです。このモジュールは MySQL データベースを使っ
て単語とドキュメントの情報を格納し、新たにドキュメントのインデックスを
作成したり、変更したり、マッチを検索するための Perl インタフェースを提
供します。DBix::FullTextSearch においては、ドキュメントはほぼなんでも
OKです -- Perl スカラ、ファイル、Web 文書、データベースフィールドなど。

<P>
The basic style of interface is shown above. What you need is a MySQL
database and a <EM>DBI</EM> with <A HREF="/DBD/mysql.html">DBD::mysql</A>. Then you create a DBIx::FullTextSearch index -- a set of tables that
maintain all necessary information. Once created it can be accessed many
times, either for updating the index (adding documents) or searching.

<P>
基本的なインタフェースのスタイルは上記の通りです。必要なのは MySQL デー
タベースと <EM>DBI</EM>, <A HREF="/DBD/mysql.html">DBD::mysql</A> です。次に DBIx::FullTextSearch イン
デクスをつくります。このインデクスは、すべての必要な情報をメンテナンス
するテーブルによって構成されます。一度つくれば、インデクスの更新 (ドキュ
メントの追加)や検索用に、何度でもアクセスすることができます。

<P>
DBIx::FullTextSearch uses one basic table to store parameters of the index.
Second table is used to store the actual information about documents and
words, and depending on the type of the index (specified during index
creation) there may be more tables to store additional information (like
conversion from external string names (eg. URL's) to internal numeric
form). For a user, these internal thingies and internal behaviour of the
index are not important. The important part is the API, the methods to
index document and ask questions about words in documents. However, certain
understanding of how it all works may be usefull when you are deciding if
this module is for you and what type of index will best suit your needs.

<P>
DBIx::FullTextSearch はまずベースのテーブルにインデクスのパラメータを
格納します。2つめのテーブルに、ドキュメントと単語、またインデクスのタ
イプ(インデクスの作成時に指定)によって、他の情報を格納するためのテーブ
ルをいくつか使用します(外部の文字列(URLなど)から内部の数値への変換表な
ど)。ユーザにとっては、こうした内部のものごとやインデクスの振る舞いは
重要ではありません。重要なのはAPI、つまりドキュメントのインデクス生成
やドキュメント内の単語へのクエリを行うメソッドです。しかし、全体として
どのように動作するのかをある程度知っておくことは、このモジュールを使用
すべきか決定したり、どのタイプのインデクスが最適かを選択する際にきっと
有益でしょう。

<P>
<HR>
<H2><A NAME="Frontends">Frontends</A></H2>
<P>
<HR>
<H2><A NAME="_">フロントエンド</A></H2>
<P>
From the user, application point of view, the DBIx::FullTextSearch index
stores documents that are named in a certain way, allows adding new
documents, and provides methods to ask: ``give me list of names of
documents that contain this list of words''. The DBIx::FullTextSearch index
doesn't store the documents itself. Instead, it stores information about
words in the documents in such a structured way that it makes easy and fast
to look up what documents contain certain words and return names of the
documents.

<P>
ユーザアプリケーションの視点からみると、DBIx::FullTextSearch のインデ
クスは、何らかの形で名前づけられたドキュメントを格納し、新たにドキュメ
ントを追加でき、``この単語リストを含むドキュメントの名前を教えて''といっ
たクエリを行うメソッドを提供します。DBIx::FullTextSearch のインデクス
は、文書自身は格納しません。代わりに、ドキュメント内の単語についての情
報を構造化して保持し、特定の単語を含んだドキュメントを検索して、ドキュ
メント名を返すことを高速に行えるようにしています。

<P>
DBIx::FullTextSearch provides a couple of predefined frontend classes that
specify various types of documents (and the way they relate to their
names).

<P>
DBIx::FullTextSearch は定義済みのフロントエンドクラスをいくつか提供し
ており、それぞれにドキュメントタイプ(とそれがどのように名前と関連づい
ているか)が指定されています。

<DL>
<DT><STRONG><A NAME="item_default">default</A></STRONG><DD>
<P>
By default, user specifies the integer number of the document and the
content (body) of the document. The code would for example read

<P>
デフォルトでは、ユーザはドキュメントナンバーとドキュメントの中身(ボディ)
を指定します。

<P>
<PRE>        $fts-&gt;index_document(53, 'zastavujeme vyplaty vkladu');
</PRE>
<P>
and DBIx::FullTextSearch will remember that the document 53 contains three
words. When looking for all documents containing word (string) vklad, a
call

<P>
のようなコードを例にすると、DBIx::FullTextSearch はドキュメント53は3つ
の単語を含んでいることを覚えておきます。単語(文字列) vklad を含むすべ
てのドキュメントを検索する際には、

<P>
<PRE>        my @docs = $fts-&gt;contains('vklad*');
</PRE>
<P>
would return numbers of all documents containing words starting with
'vklad', 53 among them.

<P>
とすると、'vklad' からはじまる単語を含むすべてのドキュメントナンバー、
ここでは 53 を返します。

<P>
So here it's user's responsibility to maintain a relation between the
document numbers and their content, to know that a document 53 is about
vklady. Perhaps the documents are already stored somewhere and have unique
numeric id.

<P>
よってここではドキュメントナンバーと中身のリレーション、つまりドキュメ
ント53が vklady についてのものである関係をメンテナンスするのはユーザの
責任です。ドキュメントはすでに他の場所で格納され、ユニークな数値のIDを
持っているような場合です。

<P>
Note that the numeric id must be no larger than 2^<A HREF="#item_doc_id_bits">doc_id_bits</A>.

<P>
数値IDは 2^<A HREF="#item_doc_id_bits">doc_id_bits</A> より大きくてはいけないことに注意してください。

<DT><STRONG><A NAME="item_string">string</A></STRONG><DD>
<P>
Frontend <STRONG>string</STRONG> allows the user to specify the names of the documents as strings, instead
of numbers. Still the user has to specify both the name of the document and
the content:

<P>
フロントエンド <STRONG>string</STRONG> を使うと、ユーザはドキュメントの名前を数値で
はなく、文字列で指定することができます。ここでもユーザはドキュメント名
と中身を指定する必要があります。

<P>
<PRE>        $fts-&gt;index_document('foobar',
                        'the quick brown fox jumped over lazy dog!');
</PRE>
<P>
After that,

<P>
そうしたら、

<P>
<PRE>        $fts-&gt;contains('dog')
</PRE>
<P>
will return 'foobar' as one of the names of documents with word 'dog' in
it.

<P>
は 'dog' を含むドキュメントの名前として 'foobar' を返します。

<DT><STRONG><A NAME="item_file">file</A></STRONG><DD>
<P>
To index files, use the frontend <STRONG>file</STRONG>. Here the content of the document is clearly the content of the file
specified by the filename, so in a call to index_document, only the name is
needed -- the content of the file is read by the DBIx::FullTextSearch
transparently:

<P>
ファイルをインデクスするには、フロントエンド <STRONG>file</STRONG> を使います。ここ
ではドキュメントの中身は明らかにファイル名によって指定されるファイルの
中身ですから、index_document を呼ぶ際には名前だけしか必要ありません。
ファイルの中身の読み込みは DBIx::FullTextSearch によって透過的に行われ
ます。

<P>
<PRE>        $fts-&gt;index_document('/usr/doc/FAQ/Linux-FAQ');
        my @files = $fts-&gt;contains('penguin');
</PRE>
<DT><STRONG><A NAME="item_url">url</A></STRONG><DD>
<P>
Web document can be indexed by the frontend <STRONG>url</STRONG>. DBIx::FullTextSearch uses <EM>LWP</EM> to get the document and then parses it normally:

<P>
フロントエンド <STRONG>url</STRONG> でウェブ文書のインデクスが行えます。 DBIx::FullTextSearch は <EM>LWP</EM> を使ってドキュメントを取得し、通常通り パースします:

<P>
<PRE>        $fts-&gt;index_document('<A HREF="http://www.perl.com/">http://www.perl.com/</A>');
</PRE>
<P>
Note that the HTML tags themselves are indexed along with the text.

<P>
HTML タグもテキスト同様にインデクスされることに注意してください。

<DT><STRONG><A NAME="item_table">table</A></STRONG><DD>
<P>
You can have a DBIx::FullTextSearch index that indexes char or blob fields
in MySQL table. Since MySQL doesn't support triggers, you have to call the
<A HREF="#item_index_document">index_document</A> method of DBIx::FullTextSearch any time something changes in the table. So
the sequence probably will be

<P>
DBIx::FullTextSearch を使って MySQL テーブルの char あるいは blob の
フィールドにインデクスをはることができます。MySQL はトリガをサポートし
ていないため、DBIx::FullTextSearch の <A HREF="#item_index_document">index_document</A> メソッドをテー ブルが変更する度に呼び出す必要があります。順序としては、

<P>
<PRE>        $dbh-&gt;do('insert into the_table (id, data, other_fields)
                values (?, ?, ?)', {}, $name, $data, $date_or_something);
        $fts-&gt;index_document($name);
</PRE>
<P>
のようになるでしょう。

<P>
When calling <A HREF="#item_contains">contains</A>, the id (name) of the record will be returned. If the id in the_table is
numeric, it's directly used as the internal numeric id, otherwise a
string's way of converting the id to numeric form is used.

<P>
<A HREF="#item_contains">contains</A> を呼ぶと、レコードの id (名前) が返ります。the_table の id
が数値なら、内部の数値id としてそのまま使用できますし、そうでなければ
string と同様の方法で id から数値に変換されます。

<P>
When creating this index, you'll have to pass it three additionial options,
<A HREF="#item_table_name">table_name</A>, <A HREF="#item_column_name">column_name</A>, and <A HREF="#item_column_id_name">column_id_name</A>. You may use the optional column_process option to pre-process data in the
specified columns.

<P>
このインデクスをつくる際には、3つのオプション <A HREF="#item_table_name">table_name</A>,
<A HREF="#item_column_name">column_name</A>, <A HREF="#item_column_id_name">column_id_name</A> を指定する必要があります。オプション
として、指定されたカラムのデータに整形処理を行うための column_process
オプションも用意されています。

</DL>
<P>
The structure of DBIx::FullTextSearch is very flexible and adding new
frontend (what will be indexed) is very easy.

<P>
DBIx::FullTextSearch の構造はとてもフレキシブルなので、新たなフロント
エンド(なにがインデクスされるか)を追加するのはとても簡単です。

<P>
<HR>
<H2><A NAME="Backends">Backends</A></H2>
<P>
<HR>
<H2><A NAME="_">バックエンド</A></H2>
<P>
While frontend specifies what is indexed and how the user sees the
collection of documents, backend is about low level database way of
actually storing the information in the tables. Three types are available:

<P>
フロントエンドがなにをインデクスするか、またユーザがドキュメントの集合
をどのように扱うかを指定するのに対し、バックエンドはローレベルで実際に
どのようにテーブルへ情報を格納するかを定義します。3つのタイプが利用可
能です。

<DL>
<DT><STRONG><A NAME="item_blob">blob</A></STRONG><DD>
<P>
For each word, a blob holding list of all documents containing that word is
stored in the table, with the count (number of occurencies) associated with
each document number. That makes it for very compact storage. Since the
document names (for example URL) are internally converted to numbers,
storing and fetching the data is fast. However, updating the information is
very slow, since information concerning one document is spread across all
table, without any direct database access. Updating a document (or merely
reindexing it) requires update of all blobs, which is slow.

<P>
各単語について、blob はその単語を含むすべてのドキュメントのリストを、
ドキュメントナンバーと出現回数とともにテーブルに保持します。ストレージ
はとてもコンパクトになります。ドキュメント名(たとえばURL)は内部で数値
に変換されるので、データの格納や取得は高速です。しかし、ドキュメントの
更新(あるいは単なる再インデクス)はすべての blob を更新する必要があり、
遅いです。

<P>
The list of documents is stored sorted by document name so that fetching an
information about a document for one word is relatively easy, still a need
to update (or at least scan) all records in the table makes this storage
unsuitable for collections of documents that often change.

<P>
ドキュメントのリストはドキュメント名でソートされ、1つの単語のドキュメ
ントの情報を取得するのは比較的容易になっていますが、テーブルの全レコー
ドを更新 (あるいはスキャン) する必要があるため、頻繁に更新されるドキュ
メントコレクションにはこの格納方法は向いていないでしょう。

<DT><STRONG><A NAME="item_column">column</A></STRONG><DD>
<P>
The <STRONG>column</STRONG> backend stores a word/document pair in database fields, indexing both, thus
allowing both fast retrieval and updates -- it's easy to delete all records
describing one document and insert new ones. However, the database indexes
that have to be maintained are large.

<P>
<STRONG>column</STRONG> バックエンドはデータベースのフィールドに単語/ドキュメントの
ペアを格納し、両方をインデクスするので、取得も更新も高速になっています。
つまり、あるドキュメントに関するレコードをすべて削除したり、新たに追加
したりするのは簡単です。しかし、メンテナンスするテーブルは大きくなりま す。

<P>
Both <STRONG>blob</STRONG> and <STRONG>column</STRONG> backends only store a count -- number of occurencies of the word in the
document (and even this can be switched off, yielding just a yes/no
information about the word's presence). This allows questions like

<P>
<STRONG>blob</STRONG> と <STRONG>cokumn</STRONG> はともにカウント、つまりドキュメント内の単語の出
現回数しか保存しません(またこれをオフにして、単語が出現するか否かの情
報だけにすることもできます)。よって以下のようなクエリ

<P>
<PRE>        all documents containing words 'voda' or 'Mattoni'
                but not a word 'kyselka'
</PRE>
<P>
<PRE>        'voda' か 'Mattoni' を含むが 'kyselka' を含まないドキュメント
</PRE>
<P>
but you cannot ask whether a document contains a phrase 'kyselka Mattoni'
because such information is not maintained by these types of backends.

<P>
を実行できますが、あるドキュメントが 'kyselka Mattoni' というフレーズ
を含んでいるかどうかを知ることはできません。そうした情報はこれらのバッ
クエンドではメンテナンスされていないためです。

<DT><STRONG><A NAME="item_phrase">phrase</A></STRONG><DD>
<P>
To allow phrase matching, a <STRONG>phrase</STRONG> backend is available. For each word and document number it stores a blob of
lists of positions of the word in the document. A query

<P>
フレーズマッチングを実現するのに、<STRONG>phrase</STRONG> バックエンドを利用できます。
単語とドキュメントナンバーごとに、ドキュメント内の出現個所のリストを blob
で保存します。

<P>
<PRE>        $fts-&gt;contains('kyselk* Mattoni');
</PRE>
<P>
then only returns those documents (document names/numbers) where word
kyselka (or kyselky, or so) is just before word Mattoni.

<P>
というクエリは、単語 kyselka (あるいは kyselky など) が単語 Mattoni の
直前にあるドキュメント (ドキュメント名/ナンバー) しか返しません。

</DL>
<P>
<HR>
<H2><A NAME="Mixing_frontends_and_backends">Mixing frontends and backends</A></H2>
<P>
<HR>
<H2><A NAME="_">フロントエンドとバックエンドの融合</A></H2>
<P>
Any frontend can be used with any backend in one DBIx::FullTextSearch
index. You can index Web documents with <A HREF="#item_url">url</A> frontend and <A HREF="#item_phrase">phrase</A> backend to be able to find phrases in the documents. And you can use the
default, number based document scheme with <A HREF="#item_blob">blob</A> backend to use the disk space as efficiently as possible -- this is usefull
for example for mailing-list archives, where we need to index huge number
of documents that do not change at all.

<P>
ひとつの DBIx::FullTextSearch インデクスで、任意のフロントエンドとバッ
クエンドを使用できます。フロントエンド <A HREF="#item_url">url</A> で Web 文書をインデクス して、<A HREF="#item_phrase">phrase</A> バックエンドでドキュメント内のフレーズを検索るというわ
けです。デフォルトにすれば、ナンバーベースのドキュメントスキームと、
<A HREF="#item_blob">blob</A> バックエンドによってディスクスペースをなるべく効率的に使えます。
たとえばメーリングリストのアーカイブのように、あまり変化しない膨大な数
のドキュメントをインデクスする必要があるときには便利でしょう。

<P>
Finding optimal combination is very important and may require some analysis
of the document collection and manipulation, as well as the speed and
storage requirements. Benchmarking on actual target platform is very useful
during the design phase.

<P>
最適な組合せを見付けるのはとても重要ですが、ドキュメントのコレクション
と操作についての分析や、速度やストレージに関する要件を必要とします。設
計フェーズにおいて実際のプラットフォーム上でベンチマークをしてみると大
変有益です。

<P>
<HR>
<H1><A NAME="METHODS">METHODS</A></H1>
<P>
The following methods are available on the user side as
DBIx::FullTextSearch API.

<P>
DBIx::FullTextSearch API
として、以下のメソッドがユーザサイドで利用可能です。

<DL>
<DT><STRONG><A NAME="item_create">create</A></STRONG><DD>
<P>
<PRE>        my $fts = DBIx::FullTextSearch-&gt;create($dbh, $index_name, %opts);
</PRE>
<P>
The class method <A HREF="#item_create">create</A> creates index of given name (the name of the index is the name of its basic
parameter table) and all necessary tables, returns an object -- newly
created index. The options that may be specified after the index name
define the frontend and backend types, storage parameters (how many bits
for what values), etc. See below for list of create options and discussion
of their use.

<P>
クラスメソッド <A HREF="#item_create">create</A> は、指定した名前(インデクスの名前はベースとな
るパラメータテーブルの名前です)のインデクスと必要なテーブルをすべて作
成し、オブジェクト、つまり新しく作られたインデクスを返します。インデク
ス名の後に指定されるオプションは、フロントエンドとバックエンドのタイプ、
ストレージのパラメータ (値ごとのビット数) などを定義します。create の
オプションリストやその使用方法については、以下を参照してください。

<DT><STRONG><A NAME="item_open">open</A></STRONG><DD>
<P>
<PRE>        my $fts = DBIx::FullTextSearch-&gt;open($dbh, $index_name);
</PRE>
<P>
Opens and returns object, accessing specifies DBIx::FullTextSearch index.
Since all the index parameters and information are stored in the <CODE>$index_name</CODE> table (including names of all other needed tables), the database handler
and the name of the parameter table are the only needed arguments.

<P>
指定された DBIx::FullTextSearch のオブジェクトを返します。インデクスの
パラメータはすべて(他に必要なテーブル名も含め) <CODE>$index_name</CODE> テーブル
に保存されていますので、データベースハンドラとパラメータテーブルの名前
のみが必要です。

<DT><STRONG><A NAME="item_index_document">index_document</A></STRONG><DD>
<P>
<PRE>        $fts-&gt;index_document(45, 'Sleva pri nakupu stribra.');
        $fts-&gt;index_document('<A HREF="http://www.mozilla.org/">http://www.mozilla.org/</A>');
        $fts-&gt;index_document('<A HREF="http://www.mozilla.org/">http://www.mozilla.org/</A>','This is the mozilla web site');
</PRE>
<P>
For the <A HREF="#item_default">default</A> and <A HREF="#item_string">string</A> frontends, two arguments are expected -- the name (number or string) of the
document and its content. For <A HREF="#item_file">file</A>,
<A HREF="#item_url">url</A>, and <A HREF="#item_table">table</A> frontends the content is optional. Any content that you pass will be
appended to the content from the file, URL, or database table.

<P>
<A HREF="#item_default">default</A> と <A HREF="#item_string">string</A> フロントエンドの場合、2つの引数が求められます -- ドキュメント名
(数値もしくは文字列) とその中身です。<A HREF="#item_file">file</A>,
<A HREF="#item_url">url</A>, <A HREF="#item_table">table</A> フロントエンドの場合は中身は省略可能です。中身を何か
渡すと、そのファイル、URL、データベーステーブルから取得した中身にアペ
ンドされます。

<DT><STRONG><A NAME="item_delete_document">delete_document</A></STRONG><DD>
<P>
<PRE>        $fts-&gt;delete_document('<A HREF="http://www.mozilla.org/">http://www.mozilla.org/</A>');
</PRE>
<P>
Removes information about document from the index. Note that for <A HREF="#item_blob">blob</A>
backend this is very time consuming process.

<P>
インデクスからドキュメントに関する情報を削除します。<A HREF="#item_blob">blob</A> バックエン
ドの場合これは非常に時間がかかるプロセスであることに注意してください。

<DT><STRONG><A NAME="item_contains">contains</A></STRONG><DD>
<P>
<PRE>        my @docs = $fts-&gt;contains('sleva', 'strib*');
</PRE>
<P>
Returns list of names (numbers or strings, depending on the frontend) of
documents that contain some of specified words.

<P>
指定された単語のいくつかを含むドキュメント名のリスト (フロントエンド次
第で、数値もしくは文字列となる)を返します。

<DT><STRONG><A NAME="item_econtains">econtains</A></STRONG><DD>
<P>
<PRE>        my @docs = $fts-&gt;econtains('foo', '+bar*', '-koo');
</PRE>
<P>
Econtains stands for extended contains and allows words to be prefixed by
plus or minus signs to specify that the word must or mustn't be present in
the document for it to match.

<P>
econatins は extended contains を意味し、プラスやマイナスを先頭につけ
ることによって、マッチすべきドキュメントに素の単語が出現するかしないか
を指定できます。

<DT><STRONG><A NAME="item_search">search</A></STRONG><DD>
<P>
<PRE> my @docs = $fts-&gt;search(qq{+&quot;this is a phrase&quot; -koo +bar foo});
</PRE>
<P>
This is a wrapper to econtains which takes a user input string and parses
it into can-include, must-include, and must-not-include words and phrases.

<P>
econtains へのラッパで、ユーザの入力文字列を受け取って、含んでもよい/
含まなくてはならない/含んではならない単語とフレーズにパースします。

<DT><STRONG><A NAME="item_contains_hashref">contains_hashref, econtains_hashref, search_hashref</A></STRONG><DD>
<P>
Similar to <A HREF="#item_contains">contains</A>, <A HREF="#item_econtains">econtains</A> and <A HREF="#item_search">search</A>, only instead of list of document names, these methods return a hash
reference to a hash where keys are the document names and values are the
number of occurencies of the words.

<P>
<A HREF="#item_contains">contains</A>, <A HREF="#item_econtains">econtains</A>, <A HREF="#item_search">search</A> に似ていますが、ドキュメント名の
リストではなく、キーがドキュメント名で値が単語のドキュメント内出現回数
となるハッシュリファレンスのリストを返します。

<DT><STRONG><A NAME="item_drop">drop</A></STRONG><DD>
<P>
Removes all tables associated with the index, including the base parameter
table. Effectivelly destroying the index form the database.

<P>
インデクスに関連するテーブルを、ベースパラメータテーブルを含め、すべて
削除します。データベースからインデクスを効率的に削除できます。

<P>
<PRE> $fts-&gt;drop;
</PRE>
<DT><STRONG><A NAME="item_empty">empty</A></STRONG><DD>
<P>
Emptys the index so you can reindex the data.

<P>
インデクスを空にしてデータを再インデクスできるようにします。

<P>
<PRE> $fts-&gt;empty;
</PRE>
</DL>
<P>
<HR>
<H1><A NAME="INDEX_OPTIONS">INDEX OPTIONS</A></H1>
<P>
Here we list the options that may be passed to <A HREF="#item_create">create</A> method. These allow to specify the style and storage parameters in great
detail.

<P>
<A HREF="#item_create">create</A> メソッドに渡すオプションのリストです。スタイルやストレージの
パラメータを細かく指定することができます。

<DL>
<DT><STRONG><A NAME="item_backend">backend</A></STRONG><DD>
<P>
The backend type, default <A HREF="#item_blob">blob</A>, possible values <A HREF="#item_blob">blob</A>, <A HREF="#item_column">column</A> and <A HREF="#item_phrase">phrase</A>
(see above for explanation).

<P>
バックエンドのタイプ。デフォルトは <A HREF="#item_blob">blob</A> で、とりうる値は <A HREF="#item_blob">blob</A>,
<A HREF="#item_column">column</A>, <A HREF="#item_phrase">phrase</A> (詳細な説明は上部参照)

<DT><STRONG><A NAME="item_frontend">frontend</A></STRONG><DD>
<P>
The frontend type. The <A HREF="#item_default">default</A> frontend requires the user to specify numeric id of the document together
with the content of the document, other possible values are <A HREF="#item_string">string</A>, <A HREF="#item_file">file</A> and <A HREF="#item_url">url</A> (see above for more info).

<P>
フロントエンドのタイプ。<A HREF="#item_default">default</A> フロントエンドはユーザがドキュメン トの数値 id
と中身を指定する必要がある。ほかにとりうる値は <A HREF="#item_string">string</A>,
<A HREF="#item_file">file</A>, <A HREF="#item_url">url</A>, <A HREF="#item_table">table</A> (詳細な説明は上記参照)。

<DT><STRONG><A NAME="item_word_length">word_length</A></STRONG><DD>
<P>
Maximum length of words that may be indexed, default 30.

<P>
インデクスされる単語の最大長。デフォルトは 30。

<DT><STRONG><A NAME="item_data_table">data_table</A></STRONG><DD>
<P>
Name of the table where the actual data about word/document relation is
stored. By default, the name of the index (of the base table) with _data
suffix is used.

<P>
実際の単語/ドキュメントリレーションを格納するテーブル名。デフォルトで
は、インデクス名 (ベーステーブル名) の後ろに _data をくっつけたもの。

<DT><STRONG><A NAME="item_name_length">name_length</A></STRONG><DD>
<P>
Any frontend that uses strings as names of documents needs to maintain a
conversion table from these names to internal integer ids. This value
specifies maximum length of these string names (URLs, file names, ...).

<P>
ドキュメント名に文字列を使うフロントエンドでは、これらの名前から整数値 の
id への変換表をメンテナンスする必要があります。この値はこうした文字 列
(URL, ファイル名) の最大長を指定します。

<DT><STRONG><A NAME="item_blob_direct_fetch">blob_direct_fetch</A></STRONG><DD>
<P>
Only for <A HREF="#item_blob">blob</A> backend. When looking for information about specific document in the list
stored in the blob, the blob backend uses division of interval to find the
correct place in the blob. When the interval gets equal or shorter that
this value, all values are fetched from the database and the final search
is done in Perl code sequentially.

<P>
<A HREF="#item_blob">blob</A> バックエンドのみ。blob で保存したドキュメントリストについて情
報を検索する際、blob バックエンドは blob の中身をインターバルごとに分
割して検索します。インターバルがこの値より小さい場合、すべての値をデー
タベースから取得して、最終的な検索は Perl コードで行われます。

<DT><STRONG><A NAME="item_word_id_bits">word_id_bits</A></STRONG><DD>
<P>
With <A HREF="#item_column">column</A> or <CODE>phase</CODE> backends, DBIx::FullTextSearch maintains a numeric id for each word to
optimize the space requirements. The word_id_bits parameter specifies the
number of bits to reserve for this conversion and thus effectively limits
number of distinct words that may be indexed. The default is 16 bits and
possible values are 8, 16, 24 or 32 bits.

<P>
<A HREF="#item_column">column</A> や <CODE>phase</CODE> バックエンドでは、DBIx::FullTextSearch はスペー
ス節約のために、各単語に数値の id を割り当ててメンテナンスしています。
word_id_bits パラメータはこの変換表で使うビット数を指定し、インデクス
で許容される単語を効率的に制限することができます。デフォルトは16bit で、
とりうる値は 8, 16, 24, 32 ビットです。

<DT><STRONG><A NAME="item_word_id_table">word_id_table</A></STRONG><DD>
<P>
Name of the table that holds conversion from words to their numeric id (for <A HREF="#item_column">column</A> and <A HREF="#item_phrase">phrase</A> backends). By default is the name of the index with _words suffix.

<P>
単語から数値idへの変換表を保持するテーブル名(<A HREF="#item_column">column</A> と <A HREF="#item_phrase">phrase</A> バッ クエンド向け)。デフォルトでは、インデクスの名前の後ろに _words をつけ
たもの。

<DT><STRONG><A NAME="item_doc_id_bits">doc_id_bits</A></STRONG><DD>
<P>
A number of bits to hold a numeric id of the document (that is either
provided by the user (with <A HREF="#item_default">default</A> frontend) or generated by the module to accomplish the conversion from the
string name of the document). This value limits the maximum number of
documents to hold. The default is 16 bits and possible values are 8, 16 and
32 bits for <A HREF="#item_blob">blob</A> backend and 8, 16, 24 and 32 bits for <A HREF="#item_column">column</A> and <A HREF="#item_phrase">phrase</A> backends.

<P>
ドキュメントの数値id (ユーザによって指定される(<A HREF="#item_default">default</A> バックエンド)
か、モジュールによってドキュメントの文字列名から変換されて生成される)
を保持するビット数。この値によって、保持するドキュメント数の最大値が制
限されます。デフォルトでは 16ビットで、とりうる値は <A HREF="#item_blob">blob</A> バックエン ドでは 8, 16, 32 bit, <A HREF="#item_column">column</A> と <A HREF="#item_phrase">phrase</A> バックエンドでは 8, 16, 24, 32 bit です。

<DT><STRONG><A NAME="item_doc_id_table">doc_id_table</A></STRONG><DD>
<P>
Name of the table that holds conversion from string names of documents to
their numeric id, by default the name of the index with _docid suffix.

<P>
ドキュメントの文字列名から数値 id への変換表を保持するテーブル名。デフォ
ルトではインデクスの名前に _docid をつけたもの。

<DT><STRONG><A NAME="item_count_bits">count_bits</A></STRONG><DD>
<P>
Number of bits reserved for storing number of occurencies of each word in
the document. The default is 8 and possible values are the same as with
doc_id_bits.

<P>
ドキュメント内の各単語の出現数を保存するためのビット数。デフォルトは 8bit
で、とりうる値は doc_id_bits と同じです。

<DT><STRONG><A NAME="item_position_bits">position_bits</A></STRONG><DD>
<P>
With <CODE>phrase backend</CODE>, DBIx::FullTextSearch stores positions of each word of the documents. This
value specifies how much space should be reserved for this purpose. The
default is 32 bits and possible values are 8, 16 or 32 bits. This value
limits the maximum number of words of each document that can be stored.

<P>
<CODE>phase</CODE> バックエンドでは、DBIx::FullTextSearch は各単語のドキュメント
内の位置を保存します。この値は、この目的のために使用するスペースを指定
します。デフォルトは 32bit で、とりうる値は 8, 16, 32 ビットです。この
値によって、各ドキュメントが保持できる単語の最大数が制限されます。

<DT><STRONG><A NAME="item_index_splitter">index_splitter</A></STRONG><DD>
<P>
DBIx::FullTextSearch allows the user to provide any Perl code that will be
used to split the content of the document to words when indexing documents.
The code will be evalled inside of the DBIx::FullTextSearch code. The
default is

<P>
DBIx::FullTextSearch は、ドキュメントのインデクシングの際、ユーザの指
定した任意のPerl コードによってドキュメントの中身を単語に分割すること
ができます。コードは DBIx::FullTextSearch のコード内で eval されます。
デフォルトは

<P>
<PRE>        /(\w{2,$word_length})/g
</PRE>
<P>
and shows that the input is stored in the variable <CODE>$data</CODE> and the code may access any other variable available in the
perl_and_index_data_* methods (see source), especially <A HREF="#item__word_length">$word_length</A> to get the maximum length of words and <A HREF="#item__backend">$backend</A> to get the backend object.

<P>
で、入力は変数 <CODE>$data</CODE> に格納されていて、コードは他にも perl_and_index_data_*
メソッド内で利用可能な変数、特に <A HREF="#item__word_length">$word_length</A> 
で単語の最大長、<A HREF="#item__backend">$backend</A> でバックエンドオブジェクトにアクセスできる
ことができます(詳しくはソースを見てください)。

<P>
The default value also shows that by default, the minimum length of words
indexed is 2.

<P>
デフォルト値によると、インデクスされる単語の長さの最小値は 2 です。

<DT><STRONG><A NAME="item_search_splitter">search_splitter</A></STRONG><DD>
<P>
This is similar to the <A HREF="#item_index_splitter">index_splitter</A> method, except that it is used in the <A HREF="#item_contains_hashref">contains_hashref</A> method when searching for documents instead of when indexing documents. The
default is

<P>
<A HREF="#item_index_splitter">index_splitter</A> メソッドに似ていますが、ドキュメントのインデクシング ではなく、<CODE>contains_hasherf</CODE> メソッドでドキュメントを検索する際に使わ れます。デフォルトは

<P>
<PRE>       /([a-zA-Z_0-9]{2,$word_length}\*?)/g
</PRE>
<P>
Which, unlike the default <A HREF="#item_index_splitter">index_splitter</A>, allows for the wild card character (*).

<P>
で、デフォルトの <A HREF="#item_index_splitter">index_splitter</A> とちがって、ワイルドカード文字 (*) が使用可能です。

<DT><STRONG><A NAME="item_filter">filter</A></STRONG><DD>
<P>
The output words of splitter (and also any parameter of (e)contains*
methods) are send to filter that may do further processing. Filter is again
a Perl code, the default is

<P>
splitter によって出力された単語 (また (e)contains* メソッドのすべての
パラメータ) は filter に送られ、処理されます。filter も任意の Perl コー
ドで、デフォルトは

<P>
<PRE>        map { lc $_ }
</PRE>
<P>
showing that the filter operates on input list and by default does
conversion to lowercase (yielding case insensitive index).

<P>
で、入力のリストに対してデフォルトで lowercase 変換をかける (つまり大
文字小文字をインデクスで区別しない) ことがわかります。

<DT><STRONG><A NAME="item_init_env">init_env</A></STRONG><DD>
<P>
Because user defined splitter or filter may depend on other things that it
is reasonable to set before the actual procession of words, you can use yet
another Perl hook to set things up. The default is

<P>
ユーザ定義の splitter や filter は、実際の単語処理の前に実行されるべき
ものに依存していることが考えられるので、セットアップ用の Perl フックも
利用できます。デフォルトは

<P>
<PRE>        use locale
</PRE>
<P>
です。

<DT><STRONG><A NAME="item_stoplist">stoplist</A></STRONG><DD>
<P>
This is the name of a <A HREF="/DBIx/FullTextSearch/StopList.html">DBIx::FullTextSearch::StopList</A> object that is used for stop words.

<P>
ストップワードに使われる <A HREF="/DBIx/FullTextSearch/StopList.html">DBIx::FullTextSearch::StopList</A> オブジェク トの名前です。

<DT><STRONG><A NAME="item_stemmer">stemmer</A></STRONG><DD>
<P>
If this option is set, then word stemming will be enabled in the indexing
and searching.

<P>
このオプションをセットすると、インデクシングと検索において、単語のステ
ミングが有効になります。

<P>
The value is the name of a <A HREF="/Lingua/Stem.html">Lingua::Stem</A> recognized locale. Currently, 'en', 'en-us' and 'en-uk' are the only
recognized locales. All locale identifiers are converted to lowercase. 

<P>
値は <A HREF="/Lingua/Stem.html">Lingua::Stem</A> が認識できる locale の名前です。locale はすべて小 文字に変換されます。

<DT><STRONG><A NAME="item_table_name">table_name</A></STRONG><DD>
<P>
For <A HREF="#item_table">table</A> frontend; this is the name of the table that will be indexed.

<P>
<A HREF="#item_table">table</A> フロントエンド用; インデクスされるテーブル名です。

<DT><STRONG><A NAME="item_column_name">column_name</A></STRONG><DD>
<P>
For <A HREF="#item_table">table</A> frontend; this is a reference to an array of columns in the
<A HREF="#item_table_name">table_name</A> that contains the documents -- data to be indexed. It can also have a form
table.column that will be used if the <A HREF="#item_table_name">table_name</A>
option is not specified.

<P>
<A HREF="#item_table">table</A> フロントエンド用; ドキュメントを含む <A HREF="#item_table_name">table_name</A> 内のカラム の配列リファレンスで、インデクスされるデータとなります。<A HREF="#item_table_name">table_name</A> 
を省略した時には、table.column という書き方を使うこともできます。

<DT><STRONG><A NAME="item_column_id_name">column_id_name</A></STRONG><DD>
<P>
For <A HREF="#item_table">table</A> frontend; this is the name of the field in <A HREF="#item_table_name">table_name</A> that holds names (ids) of the records. If not specified, a field that has
primary key on it is used. If this field is numeric, it's values are
directly used as identifiers, otherwise a conversion to numeric values is
made.

<P>
<A HREF="#item_table">table</A> フロントエンド向け; <A HREF="#item_table_name">table_name</A> のレコードの名前 (id) を保
持しているフィールド名です。指定されない場合、primary key となっている
フィールドになります。このフィールドが数値の場合、この値が直接 id とし
て利用されますが、そうでない場合は数値への変換が行われます。

</DL>
<P>
<HR>
<H1><A NAME="ERROR_HANDLING">ERROR HANDLING</A></H1>
<P>
The create and open methods return the DBIx::FullTextSearch object on
success, upon failure they return undef and set error message in <CODE>$DBIx::FullTextSearch::errstr</CODE>
variable.

<P>
create と open メソッドは成功時に DBIx::FullTextSearch オブジェクトを
返し、失敗すると undef を返し、エラーメッセージを 
<CODE>$DBIx::FullTextSearch::errstr</CODE> にセットします。

<P>
All other methods return reasonable (documented above) value on success,
failure is signalized by unreasonable (typically undef or null) return
value; the error message may then be retrieved by <CODE>$fts-&amp;gt;errstr</CODE> method call.

<P>
その他のメソッドは成功時には求められている値 (上記にドキュメントした通
り)を返し、失敗した際には何らかの (おそらく undef かヌル) の返り値でわ
かります。エラーメッセージは <CODE>$fts-&amp;gt;errstr</CODE> メソッドで取得できま す。

<P>
<HR>
<H1><A NAME="VERSION">VERSION</A></H1>
<P>
This documentation describes DBIx::FullTextSearch module version 0.60.

<P>
このドキュメントは DBIx::FullTextSearch モジュール version 0.60 につい
て記述しています。

<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
Error handling needs more polishing.

<P>
エラー処理はもうすこしきれいにする必要がある。

<P>
We do not check if the stored values are larger that specified by the
<CODE>*_bits</CODE> parameters.

<P>
格納された値が <CODE>*_bits</CODE>
パラメータで指定された値より大きいかどうかはチェッ クしていません。

<P>
No CGI administration tool at the moment.

<P>
現状、CGIのアドミニストレーションツールはありません。

<P>
No scoring algorithm implemented.

<P>
スコアリングのアルゴリズムは実装していません。

<P>
<HR>
<H1><A NAME="DEVELOPMENT">DEVELOPMENT</A></H1>
<P>
These modules are under active development. If you would like to
contribute, please e-mail <A HREF="mailto:tj@anidea.com">tj@anidea.com</A>

<P>
このモジュールは活発に開発が行われています。コントリビュートしたければ、 <A
HREF="mailto:tj@anidea.com">tj@anidea.com</A> までメールしてください。

<P>
There are two mailing lists for this module, one for users, and another for
developers. To subscribe, visit <A
HREF="http://sourceforge.net/mail/?group_id=8645">http://sourceforge.net/mail/?group_id=8645</A>


<P>
モジュールのユーザとデベロッパ向けに、2つメーリングリストがあります。
subscribe するには、 <A
HREF="http://sourceforge.net/mail/?group_id=8645">http://sourceforge.net/mail/?group_id=8645</A>
を見て ください。

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
(Original) Jan Pazdziora, <A
HREF="mailto:adelton@fi.muni.cz,">adelton@fi.muni.cz,</A> <A
HREF="http://www.fi.muni.cz/~adelton/">http://www.fi.muni.cz/~adelton/</A>
at Faculty of Informatics, Masaryk University in Brno, Czech Republic

<P>
(Current Maintainer) T.J. Mather, <A
HREF="mailto:tjmather@tjmather.com,">tjmather@tjmather.com,</A> <A
HREF="http://www.tjmather.com/">http://www.tjmather.com/</A> New York, NY,
USA

<P>
<HR>
<H1><A NAME="CREDITS">CREDITS</A></H1>
<P>
Fixes, Bug Reports, Docs have been generously provided by:

<P>
バグフィクス、レポート、ドキュメントは提供して頂いた方々:

<P>
<PRE>  Ade Olonoh
  Kate Pugh
  Sven Paulus
  Andrew Turner
  Tom Bille
  Tarik Alkasab
  Joern Reder
  Dan Collis Puro
  Tony Bowden
  Stephen Patterson
</PRE>
<P>
Of course, big thanks to Jan Pazdziora, the original author of this module.
Especially for providing a clean, modular code base!

<P>
もちろん、このモジュールの原作者である Jan Pazdziora に大いに感謝しま
す。特に、きれいなモジュールコードべースをつくってくれたことに!

<P>
<HR>
<H1><A NAME="COPYRIGHT">COPYRIGHT</A></H1>
<P>
All rights reserved. This package is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.

<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<A HREF="/DBIx/FullTextSearch/StopWord.html">DBIx::FullTextSearch::StopWord</A>,
<A HREF="/Class/DBI/mysql/FullTextSearch.html">Class::DBI::mysql::FullTextSearch</A>



<P>
<HR>
<H1><A NAME="OTHER_PRODUCTS_and_why_I_ve_writ">OTHER PRODUCTS and why I've written this module</A></H1>
<P>
(If you use Java, then I would highly recommend looking into Lucene. For
more information, see <A
HREF="http://www.lucene.com">http://www.lucene.com</A> )

<P>
(Java をお使いなら、Lucene を見てみることを強くお勧めします。詳細は <A
HREF="http://www.lucene.com">http://www.lucene.com</A> を見てください)

<P>
I'm aware of <A HREF="/DBIx/TextIndex.html">DBIx::TextIndex</A> and <A HREF="/DBIx/KwIndex.html">DBIx::KwIndex</A>
modules and about UdmSearch utility, and about htdig and glimpse on the
non-database side of the world.

<P>
<A HREF="/DBIx/TextIndex.html">DBIx::TextIndex</A> や <A HREF="/DBIx/KwIndex.html">DBIx::KwIndex</A> といったモジュールの存在や、 UdmSearch などのユーティリティ、さらには htdig
や glimse のようにデー タベースに関係ないものがあるのも知っています。

<P>
To me, using a database gives reasonable maintenance benefits. With
products that use their own files to store the information (even if the
storage algorithms are efficient and well thought of), you always struggle
with permissions on files and directories for various users, with files
that somebody accidently deleted or mungled, and making the index available
remotely is not trivial.

<P>
私にとっては、データベースを使うことでメンテナンス面での十分な利益があ
ります。情報を独自のファイルに格納するような製品 (ストレージアルゴリズ
ムが効率的でよく考えられていたとしても) の場合、多くのユーザのためのファ
イルやディレクトリのパーミッションの問題や、誰かが間違ってファイルを消
したり壊してしまったりすることといつも格闘することになり、またインデク
スをリモートで利用可能にすることは簡単ではありません。

<P>
That's why I've wanted a module that will use a database as a storage
backend. With MySQL, you get remote access and access control for free, and
on many web servers MySQL is part of the standard equipment. So using it
for text indexes seemed natural.

<P>
こうした理由で、ストレージのバックエンドにデータベースを使いたかったの
です。MySQL を使うと、リモートアクセスもアクセス制御も自由に行えますし、
多くのウェブサーバでは MySQL は標準装備されています。よってテキストの
インデクスとして MySQL を使うのは自然でしょう。

<P>
However, existing <A HREF="/DBIx/TextIndex.html">DBIx::TextIndex</A> and UdmSearch are too narrow-aimed to me. The first only supports indexing
of data that is stored in the database, but you may not always want or need
to store the documents in the database as well. The UdmSearch on the other
hand is only for web documents, making it unsuitable for indexing
mailing-list archives or local data.

<P>
しかし、既存の <A HREF="/DBIx/TextIndex.html">DBIx::TextIndex</A> や UdmSearch は私にとっては対象範囲
が狭すぎます。前者はデータベースに格納されたデータのインデクスしかサポー
トしていませんが、ドキュメントいつもデータベースに入れるとは限らないで
しょう。一方 UdmSearch はWeb文書に特化しているので、メーリングリストの
アーカイブやローカルデータのインデクスには向いていません。

<P>
I believe that DBIx::FullTextSearch is reasonably flexible and still very
efficient. It doesn't enforce its own idea of what is good for you -- the
number of options is big and you can always extend the module with your own
backend of frontend if you feel that those provided are not sufficient. Or
you can extend existing by adding one or two parameters that will add new
features. Of course, patches are always welcome. DBIx::FullTextSearch is a
tool that can be deployed in many projects. It's not a complete environment
since different people have different needs. On the other hand, the methods
that it provides make it easy to build a complete solution on top of this
in very short course of time.

<P>
DBIx::FullTextSearch は十分フレキシブルでまた十分高速だと思っています。
なにが最適かを押しつけたりはしません -- 選択肢の数は大きく、提供済みの
もので満足できなければ、いつでも独自のフロントエンドやバックエンドでモ
ジュールを拡張することができます。また、既存のものの拡張も、1つ2つのパ
ラメータの追加で新たに機能を追加することができます。もちろん、パッチは
いつでも歓迎です。 DBIx::FullTextSearch は多くのプロジェクトで利用可能
なツールです。多くの人にはそれぞれのニーズがありますから、このモジュー
ルは完全な環境ではありません。一方、このモジュールが提供しているメソッ
ドを元にして、完全なソリューションを単期間で構築するのは容易でしょう。

</BODY>

</HTML>
